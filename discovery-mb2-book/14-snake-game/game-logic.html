<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Game logic - Discovery</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Discover the world of microcontrollers through Rust with the BB2 micro:bit v2">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../01-background/index.html"><strong aria-hidden="true">1.</strong> Background</a></li><li class="chapter-item expanded "><a href="../02-requirements/index.html"><strong aria-hidden="true">2.</strong> Hardware/knowledge requirements</a></li><li class="chapter-item expanded "><a href="../03-setup/index.html"><strong aria-hidden="true">3.</strong> Setting up a development environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-setup/linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../03-setup/windows.html"><strong aria-hidden="true">3.2.</strong> Windows</a></li><li class="chapter-item expanded "><a href="../03-setup/macos.html"><strong aria-hidden="true">3.3.</strong> macOS</a></li><li class="chapter-item expanded "><a href="../03-setup/verify.html"><strong aria-hidden="true">3.4.</strong> Verify the installation</a></li><li class="chapter-item expanded "><a href="../03-setup/IDE.html"><strong aria-hidden="true">3.5.</strong> Setting up your IDE</a></li></ol></li><li class="chapter-item expanded "><a href="../04-meet-your-hardware/index.html"><strong aria-hidden="true">4.</strong> Meet your hardware</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-meet-your-hardware/microbit-v2.html"><strong aria-hidden="true">4.1.</strong> micro:bit v2</a></li><li class="chapter-item expanded "><a href="../04-meet-your-hardware/terminology.html"><strong aria-hidden="true">4.2.</strong> Rust Embedded terminology</a></li></ol></li><li class="chapter-item expanded "><a href="../05-meet-your-software/index.html"><strong aria-hidden="true">5.</strong> Meet your software</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-meet-your-software/build-it.html"><strong aria-hidden="true">5.1.</strong> Build it</a></li><li class="chapter-item expanded "><a href="../05-meet-your-software/flash-it.html"><strong aria-hidden="true">5.2.</strong> Flash it</a></li><li class="chapter-item expanded "><a href="../05-meet-your-software/debug-it.html"><strong aria-hidden="true">5.3.</strong> Debug it</a></li><li class="chapter-item expanded "><a href="../05-meet-your-software/light-it-up.html"><strong aria-hidden="true">5.4.</strong> Light it up</a></li></ol></li><li class="chapter-item expanded "><a href="../06-hello-world/index.html"><strong aria-hidden="true">6.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-hello-world/toggle-it.html"><strong aria-hidden="true">6.1.</strong> Toggle it</a></li><li class="chapter-item expanded "><a href="../06-hello-world/spin-wait.html"><strong aria-hidden="true">6.2.</strong> Spin wait</a></li><li class="chapter-item expanded "><a href="../06-hello-world/nop.html"><strong aria-hidden="true">6.3.</strong> NOP</a></li><li class="chapter-item expanded "><a href="../06-hello-world/timers.html"><strong aria-hidden="true">6.4.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../06-hello-world/portability.html"><strong aria-hidden="true">6.5.</strong> Portability</a></li><li class="chapter-item expanded "><a href="../06-hello-world/board-support-crate.html"><strong aria-hidden="true">6.6.</strong> Board support crate</a></li></ol></li><li class="chapter-item expanded "><a href="../07-registers/index.html"><strong aria-hidden="true">7.</strong> Registers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../07-registers/rtrm.html"><strong aria-hidden="true">7.1.</strong> RTRM</a></li><li class="chapter-item expanded "><a href="../07-registers/misoptimization.html"><strong aria-hidden="true">7.2.</strong> (mis)Optimization</a></li><li class="chapter-item expanded "><a href="../07-registers/bad-address.html"><strong aria-hidden="true">7.3.</strong> 0xBAAAAAAD address</a></li><li class="chapter-item expanded "><a href="../07-registers/spooky-action-at-a-distance.html"><strong aria-hidden="true">7.4.</strong> Spooky action at a distance</a></li><li class="chapter-item expanded "><a href="../07-registers/type-safe-manipulation.html"><strong aria-hidden="true">7.5.</strong> Type safe manipulation</a></li></ol></li><li class="chapter-item expanded "><a href="../08-led-roulette/index.html"><strong aria-hidden="true">8.</strong> LED roulette</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../08-led-roulette/the-challenge.html"><strong aria-hidden="true">8.1.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="../08-led-roulette/my-solution.html"><strong aria-hidden="true">8.2.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="../09-serial-communication/index.html"><strong aria-hidden="true">9.</strong> Serial communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09-serial-communication/nix-tooling.html"><strong aria-hidden="true">9.1.</strong> *nix tooling</a></li><li class="chapter-item expanded "><a href="../09-serial-communication/windows-tooling.html"><strong aria-hidden="true">9.2.</strong> Windows tooling</a></li></ol></li><li class="chapter-item expanded "><a href="../10-uart/index.html"><strong aria-hidden="true">10.</strong> UART</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10-uart/send-a-single-byte.html"><strong aria-hidden="true">10.1.</strong> Send a single byte</a></li><li class="chapter-item expanded "><a href="../10-uart/send-a-string.html"><strong aria-hidden="true">10.2.</strong> Send a string</a></li><li class="chapter-item expanded "><a href="../10-uart/naive-approach-write.html"><strong aria-hidden="true">10.3.</strong> Naive approach and write!</a></li><li class="chapter-item expanded "><a href="../10-uart/receive-a-single-byte.html"><strong aria-hidden="true">10.4.</strong> Receive a single byte</a></li><li class="chapter-item expanded "><a href="../10-uart/echo-server.html"><strong aria-hidden="true">10.5.</strong> Echo server</a></li><li class="chapter-item expanded "><a href="../10-uart/reverse-a-string.html"><strong aria-hidden="true">10.6.</strong> Reverse a string</a></li><li class="chapter-item expanded "><a href="../10-uart/my-solution.html"><strong aria-hidden="true">10.7.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="../11-i2c/index.html"><strong aria-hidden="true">11.</strong> I2C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../11-i2c/the-general-protocol.html"><strong aria-hidden="true">11.1.</strong> The general protocol</a></li><li class="chapter-item expanded "><a href="../11-i2c/lsm303agr.html"><strong aria-hidden="true">11.2.</strong> LSM303AGR</a></li><li class="chapter-item expanded "><a href="../11-i2c/read-a-single-register.html"><strong aria-hidden="true">11.3.</strong> Read a single register</a></li><li class="chapter-item expanded "><a href="../11-i2c/using-a-driver.html"><strong aria-hidden="true">11.4.</strong> Using a driver</a></li><li class="chapter-item expanded "><a href="../11-i2c/the-challenge.html"><strong aria-hidden="true">11.5.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="../11-i2c/my-solution.html"><strong aria-hidden="true">11.6.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="../12-led-compass/index.html"><strong aria-hidden="true">12.</strong> LED compass</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12-led-compass/magnitude.html"><strong aria-hidden="true">12.1.</strong> Magnitude</a></li><li class="chapter-item expanded "><a href="../12-led-compass/the-challenge.html"><strong aria-hidden="true">12.2.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="../12-led-compass/my-solution.html"><strong aria-hidden="true">12.3.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="../13-punch-o-meter/index.html"><strong aria-hidden="true">13.</strong> Punch-o-meter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../13-punch-o-meter/gravity-is-up.html"><strong aria-hidden="true">13.1.</strong> Gravity is up?</a></li><li class="chapter-item expanded "><a href="../13-punch-o-meter/the-challenge.html"><strong aria-hidden="true">13.2.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="../13-punch-o-meter/my-solution.html"><strong aria-hidden="true">13.3.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="../14-snake-game/index.html"><strong aria-hidden="true">14.</strong> Snake game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../14-snake-game/game-logic.html" class="active"><strong aria-hidden="true">14.1.</strong> Game logic</a></li><li class="chapter-item expanded "><a href="../14-snake-game/controls.html"><strong aria-hidden="true">14.2.</strong> Controls</a></li><li class="chapter-item expanded "><a href="../14-snake-game/nonblocking-display.html"><strong aria-hidden="true">14.3.</strong> Non-blocking display</a></li><li class="chapter-item expanded "><a href="../14-snake-game/final-assembly.html"><strong aria-hidden="true">14.4.</strong> Final assembly</a></li></ol></li><li class="chapter-item expanded "><a href="../explore.html"><strong aria-hidden="true">15.</strong> What's left for you to explore</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../appendix/1-general-troubleshooting/index.html">General troubleshooting</a></li><li class="chapter-item expanded affix "><a href="../appendix/2-how-to-use-gdb/index.html">How to use GDB</a></li><li class="chapter-item expanded affix "><a href="../appendix/3-mag-calibration/index.html">Magnetometer Calibration</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Discovery</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/discovery-mb2/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="game-logic"><a class="header" href="#game-logic">Game logic</a></h1>
<p>The first module we will build is the game logic. You are probably familiar with <a href="https://en.wikipedia.org/wiki/Snake_%28video_game_genre%29">snake</a> games, but
if not, the basic idea is that the player guides a snake around a 2D grid. At any given time, there
is some &quot;food&quot; at a random location on the grid and the goal of the game is to get the snake to
&quot;eat&quot; as much food as possible. Each time the snake eats food it grows in length. The player loses
if the snake crashes into its own tail.</p>
<p>In some variants of the game, the player also loses if the snake crashes into the edge of the grid,
but given the small size of our grid we are going to implement a &quot;wraparound&quot; rule: if the snake
goes off one edge of the grid, it will continue from the opposite edge.</p>
<h2 id="the-game-module"><a class="header" href="#the-game-module">The <code>game</code> module</a></h2>
<p>We will build up the game mechanics in the <code>game</code> module.</p>
<h3 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h3>
<p>We start by defining a coordinate system for our game (<code>src/game/coords.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Prng;

use heapless::FnvIndexSet;

/// A single point on the grid.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct Coords {
    // Signed ints to allow negative values (handy when checking if we have gone
    // off the top or left of the grid)
    pub row: i8,
    pub col: i8,
}

impl Coords {
    /// Get random coordinates within a grid. `exclude` is an optional set of
    /// coordinates which should be excluded from the output.
    pub fn random(rng: &amp;mut Prng, exclude: Option&lt;&amp;FnvIndexSet&lt;Coords, 32&gt;&gt;) -&gt; Self {
        let mut coords = Coords {
            row: ((rng.random_u32() as usize) % 5) as i8,
            col: ((rng.random_u32() as usize) % 5) as i8,
        };
        while exclude.is_some_and(|exc| exc.contains(&amp;coords)) {
            coords = Coords {
                row: ((rng.random_u32() as usize) % 5) as i8,
                col: ((rng.random_u32() as usize) % 5) as i8,
            }
        }
        coords
    }

    /// Whether the point is outside the bounds of the grid.
    pub fn is_out_of_bounds(&amp;self) -&gt; bool {
        self.row &lt; 0 || self.row &gt;= 5 || self.col &lt; 0 || self.col &gt;= 5
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We use a <code>Coords</code> struct to refer to a position on the grid. Because <code>Coords</code> only contains two
integers, we tell the compiler to derive an implementation of the <code>Copy</code> trait for it, so we can
pass around <code>Coords</code> structs without having to worry about ownership.</p>
<h3 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h3>
<p>We define an associated function, <code>Coords::random</code>, which will give us a random position on the
grid. We will use this later to determine where to place the snake's food.</p>
<p>To generate random coordinates, we need a source of random numbers. The nRF52833 has a hardware
random number generator (HWRNG) peripheral, documented at section 6.19 of the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf">nRF52833 spec</a>. The
HAL gives us a simple interface to the HWRNG via the <code>microbit::hal::rng::Rng</code> struct. The HWRNG may
not be fast enough for a game; it is also convenient for testing to be able to replicate the
sequence of random numbers produced by the generator between runs, which is impossible for the HWRNG
by design. We thus also define a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random</a> number generator (PRNG). The PRNG uses an
<a href="https://en.wikipedia.org/wiki/Xorshift">xorshift</a> algorithm to generate pseudo-random <code>u32</code> values. The algorithm is basic and not
cryptographically secure, but it is efficient, easy to implement and good enough for our humble
snake game. Our <code>Prng</code> struct requires an initial seed value, which we do get from the RNG
peripheral.</p>
<p>All of this makes up <code>src/game/rng.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::Rng;

/// A basic pseudo-random number generator.
pub struct Prng {
    value: u32,
}

impl Prng {
    pub fn seeded(rng: &amp;mut Rng) -&gt; Self {
        Self::new(rng.random_u32())
    }

    pub fn new(seed: u32) -&gt; Self {
        Self { value: seed }
    }

    /// Basic xorshift PRNG function: see &lt;https://en.wikipedia.org/wiki/Xorshift&gt;
    fn xorshift32(mut input: u32) -&gt; u32 {
        input ^= input &lt;&lt; 13;
        input ^= input &gt;&gt; 17;
        input ^= input &lt;&lt; 5;
        input
    }

    /// Return a pseudo-random u32.
    pub fn random_u32(&amp;mut self) -&gt; u32 {
        self.value = Self::xorshift32(self.value);
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="movement"><a class="header" href="#movement">Movement</a></h3>
<p>We also need to define a few <code>enum</code>s that help us manage the game's state: direction of movement,
direction to turn, the current game status and the outcome of a particular &quot;step&quot; in the game (ie, a
single movement of the snake). <code>src/game/movement.rs</code> contains these.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Coords;

/// Define the directions the snake can move.
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
}

/// What direction the snake should turn.
#[derive(Debug, Copy, Clone)]
pub enum Turn {
    Left,
    Right,
    None,
}

/// The current status of the game.
pub enum GameStatus {
    Won,
    Lost,
    Ongoing,
}

/// The outcome of a single move/step.
pub enum StepOutcome {
    /// Grid full (player wins)
    Full,
    /// Snake has collided with itself (player loses)
    Collision,
    /// Snake has eaten some food
    Eat(Coords),
    /// Snake has moved (and nothing else has happened)
    Move(Coords),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="a-snake-a-snaaake"><a class="header" href="#a-snake-a-snaaake">A Snake (<em>A Snaaake!</em>)</a></h3>
<p>Next up we define a <code>Snake</code> struct, which keeps track of the coordinates occupied by the snake and
its direction of travel. We use a queue (<code>heapless::spsc::Queue</code>) to keep track of the order of
coordinates and a hash set (<code>heapless::FnvIndexSet</code>) to allow for quick collision detection.  The
<code>Snake</code> has methods to allow it to move. <code>src/game/snake.rs</code> gets this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Coords, Direction, FnvIndexSet, Turn};

use heapless::spsc::Queue;

pub struct Snake {
    /// Coordinates of the snake's head.
    pub head: Coords,
    /// Queue of coordinates of the rest of the snake's body. The end of the tail is
    /// at the front.
    pub tail: Queue&lt;Coords, 32&gt;,
    /// A set containing all coordinates currently occupied by the snake (for fast
    /// collision checking).
    pub coord_set: FnvIndexSet&lt;Coords, 32&gt;,
    /// The direction the snake is currently moving in.
    pub direction: Direction,
}

impl Snake {
    pub fn make_snake() -&gt; Self {
        let head = Coords { row: 2, col: 2 };
        let initial_tail = Coords { row: 2, col: 1 };
        let mut tail = Queue::new();
        tail.enqueue(initial_tail).unwrap();
        let mut coord_set: FnvIndexSet&lt;Coords, 32&gt; = FnvIndexSet::new();
        coord_set.insert(head).unwrap();
        coord_set.insert(initial_tail).unwrap();
        Self {
            head,
            tail,
            coord_set,
            direction: Direction::Right,
        }
    }

    /// Move the snake onto the tile at the given coordinates. If `extend` is false,
    /// the snake's tail vacates the rearmost tile.
    pub fn move_snake(&amp;mut self, coords: Coords, extend: bool) {
        // Location of head becomes front of tail
        self.tail.enqueue(self.head).unwrap();
        // Head moves to new coords
        self.head = coords;
        self.coord_set.insert(coords).unwrap();
        if !extend {
            let back = self.tail.dequeue().unwrap();
            self.coord_set.remove(&amp;back);
        }
    }

    fn turn_right(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Right,
            Direction::Down =&gt; Direction::Left,
            Direction::Left =&gt; Direction::Up,
            Direction::Right =&gt; Direction::Down,
        }
    }

    fn turn_left(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Left,
            Direction::Down =&gt; Direction::Right,
            Direction::Left =&gt; Direction::Down,
            Direction::Right =&gt; Direction::Up,
        }
    }

    pub fn turn(&amp;mut self, direction: Turn) {
        match direction {
            Turn::Left =&gt; self.turn_left(),
            Turn::Right =&gt; self.turn_right(),
            Turn::None =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="game-module-top-level"><a class="header" href="#game-module-top-level">Game Module Top-Level</a></h3>
<p>The <code>Game</code> struct keeps track of the game state. It holds a <code>Snake</code> object, the current coordinates
of the food, the speed of the game (which is used to determine the time that elapses between each
movement of the snake), the status of the game (whether the game is ongoing or the player has won or
lost) and the player's score.</p>
<p>This struct contains methods to handle each step of the game, determining the snake's next move and
updating the game state accordingly. It also contains two methods--<code>game_matrix</code> and
<code>score_matrix</code>--that output 2D arrays of values which can be used to display the game state or the
player score on the LED matrix (as we will see later).</p>
<p>We put the <code>Game</code> struct at the top of the <code>game</code> module, in <code>src/game.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod coords;
mod movement;
mod rng;
mod snake;

use crate::Rng;

pub use coords::Coords;
pub use movement::{Direction, GameStatus, StepOutcome, Turn};
pub use rng::Prng;
pub use snake::Snake;

use heapless::FnvIndexSet;

/// Struct to hold game state and associated behaviour
pub struct Game {
    pub status: GameStatus,
    rng: Prng,
    snake: Snake,
    food_coords: Coords,
    speed: u8,
    score: u8,
}

impl Game {
    pub fn new(rng: &amp;mut Rng) -&gt; Self {
        let mut rng = Prng::seeded(rng);
        let mut tail: FnvIndexSet&lt;Coords, 32&gt; = FnvIndexSet::new();
        tail.insert(Coords { row: 2, col: 1 }).unwrap();
        let snake = Snake::make_snake();
        let food_coords = Coords::random(&amp;mut rng, Some(&amp;snake.coord_set));
        Self {
            rng,
            snake,
            food_coords,
            speed: 1,
            status: GameStatus::Ongoing,
            score: 0,
        }
    }

    /// Reset the game state to start a new game.
    pub fn reset(&amp;mut self) {
        self.snake = Snake::make_snake();
        self.place_food();
        self.speed = 1;
        self.status = GameStatus::Ongoing;
        self.score = 0;
    }

    /// Randomly place food on the grid.
    fn place_food(&amp;mut self) -&gt; Coords {
        let coords = Coords::random(&amp;mut self.rng, Some(&amp;self.snake.coord_set));
        self.food_coords = coords;
        coords
    }

    /// &quot;Wrap around&quot; out of bounds coordinates (eg, coordinates that are off to the
    /// left of the grid will appear in the rightmost column). Assumes that
    /// coordinates are out of bounds in one dimension only.
    fn wraparound(&amp;self, coords: Coords) -&gt; Coords {
        if coords.row &lt; 0 {
            Coords { row: 4, ..coords }
        } else if coords.row &gt;= 5 {
            Coords { row: 0, ..coords }
        } else if coords.col &lt; 0 {
            Coords { col: 4, ..coords }
        } else {
            Coords { col: 0, ..coords }
        }
    }

    /// Determine the next tile that the snake will move on to (without actually
    /// moving the snake).
    fn get_next_move(&amp;self) -&gt; Coords {
        let head = &amp;self.snake.head;
        let next_move = match self.snake.direction {
            Direction::Up =&gt; Coords {
                row: head.row - 1,
                col: head.col,
            },
            Direction::Down =&gt; Coords {
                row: head.row + 1,
                col: head.col,
            },
            Direction::Left =&gt; Coords {
                row: head.row,
                col: head.col - 1,
            },
            Direction::Right =&gt; Coords {
                row: head.row,
                col: head.col + 1,
            },
        };
        if next_move.is_out_of_bounds() {
            self.wraparound(next_move)
        } else {
            next_move
        }
    }

    /// Assess the snake's next move and return the outcome. Doesn't actually update
    /// the game state.
    fn get_step_outcome(&amp;self) -&gt; StepOutcome {
        let next_move = self.get_next_move();
        if self.snake.coord_set.contains(&amp;next_move) {
            // We haven't moved the snake yet, so if the next move is at the end of
            // the tail, there won't actually be any collision (as the tail will have
            // moved by the time the head moves onto the tile)
            if next_move != *self.snake.tail.peek().unwrap() {
                StepOutcome::Collision
            } else {
                StepOutcome::Move(next_move)
            }
        } else if next_move == self.food_coords {
            if self.snake.tail.len() == 23 {
                StepOutcome::Full
            } else {
                StepOutcome::Eat(next_move)
            }
        } else {
            StepOutcome::Move(next_move)
        }
    }

    /// Handle the outcome of a step, updating the game's internal state.
    fn handle_step_outcome(&amp;mut self, outcome: StepOutcome) {
        self.status = match outcome {
            StepOutcome::Collision =&gt; GameStatus::Lost,
            StepOutcome::Full =&gt; GameStatus::Won,
            StepOutcome::Eat(c) =&gt; {
                self.snake.move_snake(c, true);
                self.place_food();
                self.score += 1;
                if self.score % 5 == 0 {
                    self.speed += 1
                }
                GameStatus::Ongoing
            }
            StepOutcome::Move(c) =&gt; {
                self.snake.move_snake(c, false);
                GameStatus::Ongoing
            }
        }
    }

    pub fn step(&amp;mut self, turn: Turn) {
        self.snake.turn(turn);
        let outcome = self.get_step_outcome();
        self.handle_step_outcome(outcome);
    }

    /// Calculate the length of time to wait between game steps, in milliseconds.
    /// Generally this will get lower as the player's score increases, but need to
    /// be careful it cannot result in a value below zero.
    pub fn step_len_ms(&amp;self) -&gt; u32 {
        let result = 1000 - (200 * ((self.speed as i32) - 1));
        if result &lt; 200 {
            200u32
        } else {
            result as u32
        }
    }

    /// Return an array representing the game state, which can be used to display the
    /// state on the microbit's LED matrix. Each `_brightness` parameter should be a
    /// value between 0 and 9.
    pub fn game_matrix(
        &amp;self,
        head_brightness: u8,
        tail_brightness: u8,
        food_brightness: u8,
    ) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        values[self.snake.head.row as usize][self.snake.head.col as usize] = head_brightness;
        for t in &amp;self.snake.tail {
            values[t.row as usize][t.col as usize] = tail_brightness
        }
        values[self.food_coords.row as usize][self.food_coords.col as usize] = food_brightness;
        values
    }

    /// Return an array representing the game score, which can be used to display the
    /// score on the microbit's LED matrix (by illuminating the equivalent number of
    /// LEDs, going left-&gt;right and top-&gt;bottom).
    pub fn score_matrix(&amp;self) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        let full_rows = (self.score as usize) / 5;
        #[allow(clippy::needless_range_loop)]
        for r in 0..full_rows {
            values[r] = [1; 5];
        }
        for c in 0..(self.score as usize) % 5 {
            values[full_rows][c] = 1;
        }
        values
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next we will add the ability to control the snake's movements.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../14-snake-game/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../14-snake-game/controls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../14-snake-game/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../14-snake-game/controls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
