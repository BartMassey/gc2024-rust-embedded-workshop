<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Discovery</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Discover the world of microcontrollers through Rust with the BB2 micro:bit v2">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="01-background/index.html"><strong aria-hidden="true">1.</strong> Background</a></li><li class="chapter-item expanded "><a href="02-requirements/index.html"><strong aria-hidden="true">2.</strong> Hardware/knowledge requirements</a></li><li class="chapter-item expanded "><a href="03-setup/index.html"><strong aria-hidden="true">3.</strong> Setting up a development environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-setup/linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="03-setup/windows.html"><strong aria-hidden="true">3.2.</strong> Windows</a></li><li class="chapter-item expanded "><a href="03-setup/macos.html"><strong aria-hidden="true">3.3.</strong> macOS</a></li><li class="chapter-item expanded "><a href="03-setup/verify.html"><strong aria-hidden="true">3.4.</strong> Verify the installation</a></li><li class="chapter-item expanded "><a href="03-setup/IDE.html"><strong aria-hidden="true">3.5.</strong> Setting up your IDE</a></li></ol></li><li class="chapter-item expanded "><a href="04-meet-your-hardware/index.html"><strong aria-hidden="true">4.</strong> Meet your hardware</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-meet-your-hardware/microbit-v2.html"><strong aria-hidden="true">4.1.</strong> micro:bit v2</a></li><li class="chapter-item expanded "><a href="04-meet-your-hardware/terminology.html"><strong aria-hidden="true">4.2.</strong> Rust Embedded terminology</a></li></ol></li><li class="chapter-item expanded "><a href="05-meet-your-software/index.html"><strong aria-hidden="true">5.</strong> Meet your software</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-meet-your-software/build-it.html"><strong aria-hidden="true">5.1.</strong> Build it</a></li><li class="chapter-item expanded "><a href="05-meet-your-software/flash-it.html"><strong aria-hidden="true">5.2.</strong> Flash it</a></li><li class="chapter-item expanded "><a href="05-meet-your-software/debug-it.html"><strong aria-hidden="true">5.3.</strong> Debug it</a></li><li class="chapter-item expanded "><a href="05-meet-your-software/light-it-up.html"><strong aria-hidden="true">5.4.</strong> Light it up</a></li></ol></li><li class="chapter-item expanded "><a href="06-hello-world/index.html"><strong aria-hidden="true">6.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-hello-world/toggle-it.html"><strong aria-hidden="true">6.1.</strong> Toggle it</a></li><li class="chapter-item expanded "><a href="06-hello-world/spin-wait.html"><strong aria-hidden="true">6.2.</strong> Spin wait</a></li><li class="chapter-item expanded "><a href="06-hello-world/nop.html"><strong aria-hidden="true">6.3.</strong> NOP</a></li><li class="chapter-item expanded "><a href="06-hello-world/timers.html"><strong aria-hidden="true">6.4.</strong> Timers</a></li><li class="chapter-item expanded "><a href="06-hello-world/portability.html"><strong aria-hidden="true">6.5.</strong> Portability</a></li><li class="chapter-item expanded "><a href="06-hello-world/board-support-crate.html"><strong aria-hidden="true">6.6.</strong> Board support crate</a></li></ol></li><li class="chapter-item expanded "><a href="07-registers/index.html"><strong aria-hidden="true">7.</strong> Registers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07-registers/rtrm.html"><strong aria-hidden="true">7.1.</strong> RTRM</a></li><li class="chapter-item expanded "><a href="07-registers/misoptimization.html"><strong aria-hidden="true">7.2.</strong> (mis)Optimization</a></li><li class="chapter-item expanded "><a href="07-registers/bad-address.html"><strong aria-hidden="true">7.3.</strong> 0xBAAAAAAD address</a></li><li class="chapter-item expanded "><a href="07-registers/spooky-action-at-a-distance.html"><strong aria-hidden="true">7.4.</strong> Spooky action at a distance</a></li><li class="chapter-item expanded "><a href="07-registers/type-safe-manipulation.html"><strong aria-hidden="true">7.5.</strong> Type safe manipulation</a></li></ol></li><li class="chapter-item expanded "><a href="08-led-roulette/index.html"><strong aria-hidden="true">8.</strong> LED roulette</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08-led-roulette/the-challenge.html"><strong aria-hidden="true">8.1.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="08-led-roulette/my-solution.html"><strong aria-hidden="true">8.2.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="09-serial-communication/index.html"><strong aria-hidden="true">9.</strong> Serial communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09-serial-communication/nix-tooling.html"><strong aria-hidden="true">9.1.</strong> *nix tooling</a></li><li class="chapter-item expanded "><a href="09-serial-communication/windows-tooling.html"><strong aria-hidden="true">9.2.</strong> Windows tooling</a></li></ol></li><li class="chapter-item expanded "><a href="10-uart/index.html"><strong aria-hidden="true">10.</strong> UART</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10-uart/send-a-single-byte.html"><strong aria-hidden="true">10.1.</strong> Send a single byte</a></li><li class="chapter-item expanded "><a href="10-uart/send-a-string.html"><strong aria-hidden="true">10.2.</strong> Send a string</a></li><li class="chapter-item expanded "><a href="10-uart/naive-approach-write.html"><strong aria-hidden="true">10.3.</strong> Naive approach and write!</a></li><li class="chapter-item expanded "><a href="10-uart/receive-a-single-byte.html"><strong aria-hidden="true">10.4.</strong> Receive a single byte</a></li><li class="chapter-item expanded "><a href="10-uart/echo-server.html"><strong aria-hidden="true">10.5.</strong> Echo server</a></li><li class="chapter-item expanded "><a href="10-uart/reverse-a-string.html"><strong aria-hidden="true">10.6.</strong> Reverse a string</a></li><li class="chapter-item expanded "><a href="10-uart/my-solution.html"><strong aria-hidden="true">10.7.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="11-i2c/index.html"><strong aria-hidden="true">11.</strong> I2C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11-i2c/the-general-protocol.html"><strong aria-hidden="true">11.1.</strong> The general protocol</a></li><li class="chapter-item expanded "><a href="11-i2c/lsm303agr.html"><strong aria-hidden="true">11.2.</strong> LSM303AGR</a></li><li class="chapter-item expanded "><a href="11-i2c/read-a-single-register.html"><strong aria-hidden="true">11.3.</strong> Read a single register</a></li><li class="chapter-item expanded "><a href="11-i2c/using-a-driver.html"><strong aria-hidden="true">11.4.</strong> Using a driver</a></li><li class="chapter-item expanded "><a href="11-i2c/the-challenge.html"><strong aria-hidden="true">11.5.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="11-i2c/my-solution.html"><strong aria-hidden="true">11.6.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="12-led-compass/index.html"><strong aria-hidden="true">12.</strong> LED compass</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12-led-compass/magnitude.html"><strong aria-hidden="true">12.1.</strong> Magnitude</a></li><li class="chapter-item expanded "><a href="12-led-compass/the-challenge.html"><strong aria-hidden="true">12.2.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="12-led-compass/my-solution.html"><strong aria-hidden="true">12.3.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="13-punch-o-meter/index.html"><strong aria-hidden="true">13.</strong> Punch-o-meter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="13-punch-o-meter/gravity-is-up.html"><strong aria-hidden="true">13.1.</strong> Gravity is up?</a></li><li class="chapter-item expanded "><a href="13-punch-o-meter/the-challenge.html"><strong aria-hidden="true">13.2.</strong> The challenge</a></li><li class="chapter-item expanded "><a href="13-punch-o-meter/my-solution.html"><strong aria-hidden="true">13.3.</strong> My solution</a></li></ol></li><li class="chapter-item expanded "><a href="14-snake-game/index.html"><strong aria-hidden="true">14.</strong> Snake game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14-snake-game/game-logic.html"><strong aria-hidden="true">14.1.</strong> Game logic</a></li><li class="chapter-item expanded "><a href="14-snake-game/controls.html"><strong aria-hidden="true">14.2.</strong> Controls</a></li><li class="chapter-item expanded "><a href="14-snake-game/nonblocking-display.html"><strong aria-hidden="true">14.3.</strong> Non-blocking display</a></li><li class="chapter-item expanded "><a href="14-snake-game/final-assembly.html"><strong aria-hidden="true">14.4.</strong> Final assembly</a></li></ol></li><li class="chapter-item expanded "><a href="explore.html"><strong aria-hidden="true">15.</strong> What's left for you to explore</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix/1-general-troubleshooting/index.html">General troubleshooting</a></li><li class="chapter-item expanded affix "><a href="appendix/2-how-to-use-gdb/index.html">How to use GDB</a></li><li class="chapter-item expanded affix "><a href="appendix/3-mag-calibration/index.html">Magnetometer Calibration</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Discovery</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-embedded/discovery-mb2/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="microbit-v2-embedded-discovery-book"><a class="header" href="#microbit-v2-embedded-discovery-book"><code>micro::bit v2 Embedded Discovery Book</code></a></h1>
<p><strong>Danger Will Robinson! Danger!</strong></p>
<p>You are looking at a pre-release of this book, not really
ready for general use. For now, you probably want to go to
<a href="https://docs.rust-embedded.org/discovery/microbit">https://docs.rust-embedded.org/discovery/microbit</a> unless you are
working on this version.</p>
<hr />
<blockquote>
<p>Discover the world of microcontrollers through <a href="https://www.rust-lang.org/">Rust</a>!</p>
</blockquote>
<p>This book is an introductory course on microcontroller-based embedded systems that uses Rust as the
teaching language rather than the usual C/C++.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The following topics will be covered (eventually, I hope):</p>
<ul>
<li>
<p>How to write, build, flash and debug an &quot;embedded&quot; (Rust) program.</p>
</li>
<li>
<p>Functionality (&quot;peripherals&quot;) commonly found in microcontrollers: Digital input and output, Pulse
Width Modulation (PWM), Analog to Digital Converters (ADC), common communication protocols like
Serial, I2C and SPI, etc.</p>
</li>
<li>
<p>Multitasking concepts: cooperative vs preemptive multitasking, interrupts, schedulers, etc.</p>
</li>
<li>
<p>Control systems concepts: sensors, calibration, digital filters, actuators, open loop control,
closed loop control, etc.</p>
</li>
</ul>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<ul>
<li>
<p>Beginner friendly. No previous experience with microcontrollers or embedded systems is required.</p>
</li>
<li>
<p>Hands on. Plenty of exercises to put the theory into practice. <em>You</em> will be doing most of the
work here.</p>
</li>
<li>
<p>Tool centered. We'll make plenty use of tooling to ease development. &quot;Real&quot; debugging, with GDB,
and logging will be introduced early on. Using LEDs as a debugging mechanism has no place here.</p>
</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h2>
<p>What's out of scope for this book:</p>
<ul>
<li>
<p>Teaching Rust. There's plenty of material on that topic already. We'll focus on microcontrollers
and embedded systems.</p>
</li>
<li>
<p>Being a comprehensive text about electric circuit theory or electronics. We'll just cover the
minimum required to understand how some devices work.</p>
</li>
<li>
<p>Covering details such as linker scripts and the boot process. For example, we'll use existing tools
to help get your code onto your board, but not go into detail about how those tools work.</p>
</li>
</ul>
<p>Also I don't intend to port this material to other development boards; this book will make exclusive
use of the micro:bit development board.</p>
<h2 id="reporting-problems"><a class="header" href="#reporting-problems">Reporting problems</a></h2>
<p>The source of this book is in <a href="https://github.com/rust-embedded/discovery-mb2">this repository</a>. If you encounter any typo or problem with the code
report it on the <a href="https://github.com/rust-embedded/discovery-mb2/issues">issue tracker</a>.</p>
<h2 id="other-embedded-rust-resources"><a class="header" href="#other-embedded-rust-resources">Other embedded Rust resources</a></h2>
<p>This Discovery book is just one of several embedded Rust resources provided by the
<a href="https://github.com/rust-embedded/wg">Embedded Working Group</a>. The full selection can be found at <a href="https://docs.rust-embedded.org">The Embedded Rust Bookshelf</a>. This
includes the list of <a href="https://docs.rust-embedded.org/faq.html">Frequently Asked Questions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<h2 id="whats-a-microcontroller"><a class="header" href="#whats-a-microcontroller">What's a microcontroller?</a></h2>
<p>A microcontroller is a <em>system</em> on a chip. Whereas your computer is made up of several discrete
components: a processor, RAM, storage, an Ethernet port, etc.; a microcontroller has all those types
of components built into a single &quot;chip&quot; or package. This makes it possible to build systems with
fewer parts.</p>
<h2 id="what-can-you-do-with-a-microcontroller"><a class="header" href="#what-can-you-do-with-a-microcontroller">What can you do with a microcontroller?</a></h2>
<p>Lots of things! Microcontrollers are the central part of what are known as &quot;<em>embedded</em> systems&quot;.
Embedded systems are everywhere, but you don't usually notice them. They control the machines that
wash your clothes, print your documents, and cook your food. Embedded systems keep the buildings
that you live and work in at a comfortable temperature, and control the components that make the
vehicles you travel in stop and go.</p>
<p>Most embedded systems operate without user intervention. Even if they expose a user interface like a
washing machine does; most of their operation is done on their own.</p>
<p>Embedded systems are often used to <em>control</em> a physical process. To make this possible, they have
one or more devices to tell them about the state of the world (&quot;sensors&quot;), and one or more
devices which allow them to change things (&quot;actuators&quot;). For example, a building climate control
system might have:</p>
<ul>
<li>Sensors which measure temperature and humidity in various locations.</li>
<li>Actuators which control the speed of fans.</li>
<li>Actuators which cause heat to be added or removed from the building.</li>
</ul>
<h2 id="when-should-i-use-a-microcontroller"><a class="header" href="#when-should-i-use-a-microcontroller">When should I use a microcontroller?</a></h2>
<p>Many of the embedded systems listed above could be implemented with a computer running Linux (for
example a &quot;Raspberry Pi&quot;). Why use a microcontroller instead? Sounds like it might be harder to
develop a program.</p>
<p>Some reasons might include:</p>
<p><strong>Cost.</strong> A microcontroller is much cheaper than a general purpose computer. Not only is the
microcontroller cheaper; it also requires many fewer external electrical components to operate.
This makes Printed Circuit Boards (PCB) smaller and cheaper to design and manufacture.</p>
<p><strong>Power consumption.</strong> Most microcontrollers consume a fraction of the power of a full blown
processor. For applications which run on batteries, that makes a huge difference.</p>
<p><strong>Responsiveness.</strong> To accomplish their purpose, some embedded systems must always react within a
limited time interval (e.g. the &quot;anti-lock&quot; braking system of a car). If the system misses this
type of <em>deadline</em>, a catastrophic failure might occur. Such a deadline is called a &quot;hard real time&quot;
requirement. An embedded system which is bound by such a deadline is referred to as a &quot;hard
real-time system&quot;. A general purpose computer and OS usually has many software components which
share the computer's processing resources. This makes it harder to guarantee execution of a program
within tight time constraints.</p>
<p><strong>Reliability.</strong> In systems with fewer components (both hardware and software), there is less to go
wrong!</p>
<h2 id="when-should-i-not-use-a-microcontroller"><a class="header" href="#when-should-i-not-use-a-microcontroller">When should I <em>not</em> use a microcontroller?</a></h2>
<p>Microcontrollers are often not great at heavy computational work. To keep their cost and power
consumption low, microcontrollers have limited computational resources available to them.</p>
<p>Microcontrollers can typically execute fewer instructions per second than &quot;big&quot; processors. The
slowest parts might run at &quot;only&quot; a few million instructions per second. In addition, the amount of
work per instruction is typically lower. Microcontroller parts are typically &quot;32 bit&quot;, but &quot;16 bit&quot;
parts are not uncommon: this may mean more instructions to work with typical Rust datatypes. Most
microcontrollers have no or little &quot;cache&quot;, meaning instructions can run only as fast as main memory
can be accessed.</p>
<p>Some microcontrollers don't have hardware support for floating point operations. On those
devices, performing a simple addition of single precision numbers can take hundreds of CPU cycles.</p>
<p>Finally, microcontrollers typically come with limited memory. Memory sizes may be as small as 16KB
for program instructions and 4KB for data, making programming for these systems quite challenging.
While the internal memory size per unit cost and power consumption is constantly increasing, the
processor we will work with still has &quot;only&quot; 512KB for program instructions and 256KB for data — far
less than that of a &quot;real computer&quot;.</p>
<h2 id="why-use-rust-and-not-c"><a class="header" href="#why-use-rust-and-not-c">Why use Rust and not C?</a></h2>
<p>Hopefully, I don't need to convince you here as you are probably familiar with the language
differences between Rust and C. One point I do want to bring up is package management. C lacks an
official, widely accepted package management solution whereas Rust has Cargo. This makes development
<em>much</em> easier. And, IMO, easy package management encourages code reuse because libraries can be
easily integrated into an application which is also a good thing as libraries get more &quot;battle
testing&quot;.</p>
<h2 id="why-should-i-not-use-rust"><a class="header" href="#why-should-i-not-use-rust">Why should I not use Rust?</a></h2>
<p>Or why should I prefer C over Rust?</p>
<p>The C ecosystem is more mature. Off-the-shelf solutions for several problems already exist. If you
need to control a time sensitive process, you can grab one of the existing commercial Real Time
Operating Systems (RTOS) out there and solve your problem. There are no commercial, production-grade
RTOSes in Rust (as of this writing) so you would have to either create one yourself or try one of
the ones that are in development. You can find a list of those in the <a href="https://github.com/rust-embedded/awesome-embedded-rust#real-time-operating-system-rtos">Awesome Embedded Rust</a>
repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardwareknowledge-requirements"><a class="header" href="#hardwareknowledge-requirements">Hardware/knowledge requirements</a></h1>
<p>The primary knowledge requirement to read this book is to know <em>some</em> Rust. It's hard for me to
quantify <em>some</em>. Being familiar with the basics of generics and traits is quite helpful. You do need
to know how to <em>use</em> closures. You also need to be familiar with the idioms of the current Rust
<a href="https://rust-lang-nursery.github.io/edition-guide/">edition</a>.</p>
<p>Also, to follow this material you'll need:</p>
<ul>
<li>
<p>A <a href="https://tech.microbit.org/hardware/">Micro:Bit v2</a> (MB2) board.</p>
<p>You can purchase this board from many suppliers, including
Amazon and Ali Baba. You can get a <a href="https://microbit.org/buy/">list</a> of suppliers
directly from the BBC, the manufacturers of MB2.</p>
<p align="center">
<img title="micro:bit" src="02-requirements/../assets/microbit-v2.jpg" width="500"/>
</p>
<p>There are several versions of the <code>V2</code> board
available. While the material here was written for <code>V2.00</code>,
things should work fine with with any <code>V2</code> board.</p>
</li>
<li>
<p>A micro-B USB cable (nothing special — you probably have many of these). This is required
to power the micro:bit board when not on battery, and to communicate with it.  Make sure
that the cable supports data transfer, as some cables only support charging devices.</p>
<p align="center">
<img title="micro-B USB cable" src="02-requirements/../assets/usb-cable.jpg" width="500">
</p>
<blockquote>
<p><strong>NOTE</strong> Some micro:bit kits ship with such cables.  USB cables used with other mobile
devices should work, if they are micro-B and have the capability to transmit data.</p>
</blockquote>
<p>The official <code>micro:bit Go</code> kit provides both the USB cable and a nifty battery pack for powering
the MB2 without USB.</p>
</li>
</ul>
<blockquote>
<p><strong>FAQ</strong>: Wait, why do I need this specific hardware?</p>
</blockquote>
<p>It makes my life and yours much easier.</p>
<p>The material is much, much more approachable if we don't have to worry about hardware differences.
Trust me on this one.</p>
<blockquote>
<p><strong>FAQ</strong>: Can I follow this material with a different development board?</p>
</blockquote>
<p>Maybe? It depends mainly on two things: your previous experience with microcontrollers and/or
whether a high level crate already exists for your development board somewhere. You probably want at
least a HAL crate, like <a href="https://docs.rs/nrf52-hal"><code>nrf52-hal</code></a> used here.  You may prefer a board with a Board Support crate,
like [<code>microbit-v2</code>] used here.  If you intend to use a different microcontroller, you can look
through <a href="https://github.com/rust-embedded/awesome-embedded-rust">Awesome Embedded Rust</a> or just search the web to find supported crates.</p>
<p>With a different development board, this text loses most if not all its beginner friendliness and
&quot;easy to follow&quot;-ness, in my opinion: you have been warned.</p>
<p>If you have a different ARM-based development board and you don't consider yourself a total
beginner, you might consider starting with the <a href="https://rust-embedded.github.io/cortex-m-quickstart/cortex_m_quickstart/">quickstart</a> project template.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-development-environment"><a class="header" href="#setting-up-a-development-environment">Setting up a development environment</a></h1>
<p>Dealing with microcontrollers involves several tools as we'll be dealing with an architecture
different from your computer's and we'll have to run and debug programs on a &quot;remote&quot; device.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Tooling is not everything though. Without documentation, it is pretty much impossible to work with
microcontrollers. The official MB2 technical documentation is at <a href="https://tech.microbit.org">https://tech.microbit.org</a>. We
will reference other technical documentation throughout the book.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>We'll use all the tools listed below. Where a minimum version is not specified, any recent version
should work but we have listed the version we have tested.</p>
<ul>
<li>
<p>Rust 1.79.0 or a newer toolchain.</p>
</li>
<li>
<p><code>gdb-multiarch</code>. This is a debugging tool. The oldest tested version is10.2, but other versions
will most likely work as well.  If your distribution/platform does not have <code>gdb-multiarch</code>
available <code>arm-none-eabi-gdb</code> will do the trick as well. Furthermore, some normal <code>gdb</code> binaries
are built with multiarch capabilities as well: you can find further information about this in the
debugging chapter of this book.</p>
</li>
<li>
<p><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a>. Version 0.3.6 or newer.</p>
</li>
<li>
<p><a href="https://probe.rs/docs/overview/about-probe-rs/"><code>probe-rs-tools</code></a>. Version 0.24.0 or newer.</p>
</li>
<li>
<p><code>minicom</code> on Linux and macOS. Tested version: 2.7.1. Other versions will most likely work as well
though.</p>
</li>
<li>
<p><code>PuTTY</code> on Windows.</p>
</li>
</ul>
<p>Next, follow OS-agnostic installation instructions for a few of the tools:</p>
<h3 id="rustc--cargo"><a class="header" href="#rustc--cargo"><code>rustc</code> &amp; Cargo</a></h3>
<p>Install rustup by following the instructions at <a href="https://rustup.rs">https://rustup.rs</a>.</p>
<p>If you already have rustup installed, double check that you are on the stable channel and your
stable toolchain is up-to-date. <code>rustc -V</code> should return a date and version no older than the one
shown below:</p>
<pre><code class="language-console">$ rustc -V
rustc 1.79.0 (129f3b996 2024-06-10)
</code></pre>
<h3 id="cargo-binutils"><a class="header" href="#cargo-binutils"><code>cargo-binutils</code></a></h3>
<pre><code class="language-console">$ rustup component add llvm-tools
$ cargo install cargo-binutils --vers 0.3.3
$ cargo size --version
cargo-size 0.3.6
</code></pre>
<h3 id="probe-rs-tools"><a class="header" href="#probe-rs-tools"><code>probe-rs-tools</code></a></h3>
<p><strong>NOTE</strong> If you already have old versions of <code>probe-run</code>, <code>probe-rs</code> or <code>cargo-embed</code> installed on
your system, remove them before starting this step, as they could conceivably cause problems for you
down the line. In particular, <code>probe-run</code> no longer officially exists. Try these as needed:</p>
<pre><code class="language-console">$ cargo uninstall cargo-embed
$ cargo uninstall probe-run
$ cargo uninstall probe-rs
$ cargo uninstall probe-rs-cli
</code></pre>
<p>In order to install <code>probe-rs-tools</code>, first install its
<a href="https://probe.rs/docs/getting-started/installation/">prerequisites</a> (note: these instructions are
part of the more general <a href="https://probe.rs/"><code>probe-rs</code></a> embedded debugging toolkit). Then install
<code>probe-rs-tools</code> with Cargo.</p>
<pre><code class="language-console">$ cargo install --locked probe-rs-tools
</code></pre>
<p><strong>NOTE</strong> This may fail due to frequent changes in <code>probe-rs</code>. If so, go to <a href="https://probe.rs">https://probe.rs</a> and
follow the current installation instructions there.</p>
<p>Installing <code>probe-rs-tools</code> will install several useful tools, including <code>probe-rs</code> and
<code>cargo-embed</code> (which is normally run as a Cargo command). Check that things are working before
proceeding.</p>
<pre><code>$ cargo embed --version
cargo-embed 0.24.0 (git commit: crates.io)
</code></pre>
<h3 id="this-repository"><a class="header" href="#this-repository">This repository</a></h3>
<p>This book also contains some small Rust codebases used in various chapters: the easiest way to use
these is to download the book's source code. You can do this in one of the following ways:</p>
<ul>
<li>
<p>Visit the <a href="https://github.com/rust-embedded/discovery-mb2/">repository</a>, click the green &quot;Code&quot;
button and then the &quot;Download Zip&quot; one.</p>
</li>
<li>
<p>Clone it using <code>git</code> (if you know <code>git</code> you presumably already have it installed) from the same
repository as linked in the Zip approach.</p>
</li>
</ul>
<h3 id="os-specific-instructions"><a class="header" href="#os-specific-instructions">OS specific instructions</a></h3>
<p>Now follow the instructions specific to the OS you are using:</p>
<ul>
<li><a href="03-setup/linux.html">Linux</a></li>
<li><a href="03-setup/windows.html">Windows</a></li>
<li><a href="03-setup/macos.html">macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>Here are the installation commands for a few Linux distributions.</p>
<h2 id="ubuntu-2004-or-newer--debian-10-or-newer"><a class="header" href="#ubuntu-2004-or-newer--debian-10-or-newer">Ubuntu 20.04 or newer / Debian 10 or newer</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>gdb-multiarch</code> is the GDB command you'll use to debug your ARM Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo apt install gdb-multiarch minicom libunwind-dev
</code></pre>
<h2 id="fedora-32-or-newer"><a class="header" href="#fedora-32-or-newer">Fedora 32 or newer</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo dnf install gdb minicom libunwind-devel
</code></pre>
<h2 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs.</p>
</blockquote>
<pre><code class="language-console">$ sudo pacman -S arm-none-eabi-gdb minicom libunwind-dev
</code></pre>
<h2 id="other-distros"><a class="header" href="#other-distros">Other distros</a></h2>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM Cortex-M programs.</p>
</blockquote>
<p>For distros that don't have packages for <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">ARM's pre-built
toolchain</a>, download the &quot;Linux
64-bit&quot; file and put its <code>bin</code> directory on your path.  Here's one way to do it:</p>
<pre><code class="language-console">$ mkdir -p ~/local
$ cd ~/local
$ tar xjf /path/to/downloaded/XXX.tar.bz2
</code></pre>
<p>Then, use your editor of choice to append to your <code>PATH</code> in the appropriate shell init file
(e.g. <code>~/.zshrc</code> or <code>~/.bashrc</code>):</p>
<pre><code>PATH=$PATH:$HOME/local/XXX/bin
</code></pre>
<h2 id="udev-rules"><a class="header" href="#udev-rules">udev rules</a></h2>
<p>These rules let you use USB devices like the micro:bit without root privilege, i.e. <code>sudo</code>.</p>
<p>Create this file in <code>/etc/udev/rules.d</code> with the content shown below.</p>
<pre><code class="language-console">$ cat /etc/udev/rules.d/69-microbit.rules
</code></pre>
<pre><code class="language-text"># CMSIS-DAP for microbit
ACTION!=&quot;add|change&quot;, GOTO=&quot;microbit_rules_end&quot;
SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0d28&quot;, ATTR{idProduct}==&quot;0204&quot;, TAG+=&quot;uaccess&quot;
LABEL=&quot;microbit_rules_end&quot;
</code></pre>
<p>Then reload the udev rules with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload
</code></pre>
<p>If you had any board plugged to your computer, unplug them and then plug them in again, or run the
following command.</p>
<pre><code class="language-console">$ sudo udevadm trigger
</code></pre>
<h2 id="verify-permissions"><a class="header" href="#verify-permissions">Verify permissions</a></h2>
<p>Connect the micro:bit to your computer using a USB cable.</p>
<p>The micro:bit should now appear as a USB device (file) in <code>/dev/bus/usb</code>. Let's find out how it got
enumerated:</p>
<pre><code class="language-console">$ lsusb | grep -i &quot;NXP ARM mbed&quot;
Bus 001 Device 065: ID 0d28:0204 NXP ARM mbed
$ # ^^^        ^^^
</code></pre>
<p>In my case, the micro:bit got connected to the bus #1 and got enumerated as the device #65. This means the
file <code>/dev/bus/usb/001/065</code> <em>is</em> the micro:bit. Let's check the file permissions:</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/001/065
crw-rw-r--+ 1 nobody nobody 189, 64 Sep  5 14:27 /dev/bus/usb/001/065
</code></pre>
<p>The permissions should be <code>crw-rw-r--+</code>, note the <code>+</code> at the end, then see your access rights by running the following command.</p>
<pre><code class="language-console">$ getfacl /dev/bus/usb/001/065
getfacl: Removing leadin '/' from absolute path names
# file: dev/bus/usb/001/065
# owner: nobody
# group: nobody
user::rw-
user:&lt;YOUR-USER-NAME&gt;:rw-
group::rw-
mask::rw-
other::r-
</code></pre>
<p>You should see your username in the list above with the
<code>rw-</code> permissions, if not ... then check your <a href="03-setup/linux.html#udev-rules">udev rules</a>
and try re-loading them with:</p>
<pre><code class="language-console">$ sudo udevadm control --reload
$ sudo udevadm trigger
</code></pre>
<p>Now, go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<h2 id="arm-none-eabi-gdb"><a class="header" href="#arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<p>ARM provides <code>.exe</code> installers for Windows. Grab one from <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">here</a>, and follow the instructions.
Just before the installation process finishes tick/select the &quot;Add path to environment variable&quot;
option. Then verify that the tools are in your <code>%PATH%</code>:</p>
<pre><code class="language-console">$ arm-none-eabi-gcc -v
(..)
gcc version 5.4.1 20160919 (release) (..)
</code></pre>
<h2 id="putty"><a class="header" href="#putty">PuTTY</a></h2>
<p>Download the latest <code>putty.exe</code> from <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">this site</a> and place it somewhere in your <code>%PATH%</code>.</p>
<p>Now, go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>All the tools can be installed using <a href="http://brew.sh/">Homebrew</a>:</p>
<pre><code class="language-console">$ # ARM GCC debugger
$ brew install arm-none-eabi-gdb

$ # Minicom
$ brew install minicom

$ # lsusb lists USB ports
$ brew install lsusb
</code></pre>
<p>That's all! Go to the <a href="03-setup/verify.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verify-the-installation"><a class="header" href="#verify-the-installation">Verify the installation</a></h1>
<p>Let's verify that all the tools were installed correctly.</p>
<h2 id="verifying-cargo-embed"><a class="header" href="#verifying-cargo-embed">Verifying cargo-embed</a></h2>
<p>First, connect the micro:bit to your Computer using a USB cable.</p>
<p>At least an orange LED right next to the USB port of the micro:bit should light up.  Furthermore, if
you have never flashed another program on to your micro:bit, the default program the micro:bit ships
with should start blinking the red LEDs on its back: you can ignore them, or you can play with the
demo app.</p>
<p>Now let's see if probe-rs, and by extensions cargo-embed can see your micro:bit. You can do this by
running the following command:</p>
<pre><code class="language-console">$ probe-rs list
The following debug probes were found:
[0]: BBC micro:bit CMSIS-DAP -- 0d28:0204:990636020005282030f57fa14252d446000000006e052820 (CMSIS-DAP)
</code></pre>
<p>Or if you want more information about the micro:bits debug capabilities then you can run:</p>
<pre><code class="language-console">$ probe-rs info
Probing target via JTAG

Error identifying target using protocol JTAG: The probe does not support the JTAG protocol.

Probing target via SWD

ARM Chip with debug port Default:
Debug Port: DPv1, DP Designer: ARM Ltd
├── 0 MemoryAP
│   └── ROM Table (Class 1), Designer: Nordic VLSI ASA
│       ├── Cortex-M4 SCS   (Generic IP component)
│       │   └── CPUID
│       │       ├── IMPLEMENTER: ARM Ltd
│       │       ├── VARIANT: 0
│       │       ├── PARTNO: Cortex-M4
│       │       └── REVISION: 1
│       ├── Cortex-M3 DWT   (Generic IP component)
│       ├── Cortex-M3 FBP   (Generic IP component)
│       ├── Cortex-M3 ITM   (Generic IP component)
│       ├── Cortex-M4 TPIU  (Coresight Component)
│       └── Cortex-M4 ETM   (Coresight Component)
└── 1 Unknown AP (Designer: Nordic VLSI ASA, Class: Undefined, Type: 0x0, Variant: 0x0, Revision: 0x0)


Debugging RISC-V targets over SWD is not supported. For these targets, JTAG is the only supported protocol. RISC-V specific information cannot be printed.
Debugging Xtensa targets over SWD is not supported. For these targets, JTAG is the only supported protocol. Xtensa specific information cannot be printed.
</code></pre>
<p>Next, make sure you are in <code>src/03-setup</code> of this book's source code. Then run these commands:</p>
<pre><code>$ rustup target add thumbv7em-none-eabihf
$ cargo embed --target thumbv7em-none-eabihf
</code></pre>
<p>If everything works correctly cargo-embed should first compile the small example program
in this directory, then flash it and finally open a nice text based user interface that
prints Hello World.</p>
<p>(If it does not, check out <a href="03-setup/../appendix/1-general-troubleshooting/index.html">general troubleshooting</a> instructions.)</p>
<p>This output is coming from the small Rust program you just flashed on to your micro:bit.
Everything is working properly and you can continue with the next chapters!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-the-most-out-of-your-ide"><a class="header" href="#getting-the-most-out-of-your-ide">Getting the most out of your IDE</a></h1>
<p>All code in this book assumes that you use a simple terminal to build your code,
run it, and interact with it. It also makes no assumption about your text editor.</p>
<p>However, you may have your favourite IDEs, providing you auto-complete, type annotation,
your preferred shortcuts and much more. This section explains how to get the most out
of your IDE using the code obtained from this book's repo.</p>
<h1 id="ide-configuration"><a class="header" href="#ide-configuration">IDE configuration</a></h1>
<p>Below, we explain how to configure your IDE to get the most out of this book.
If your IDE is not listed below, please improve this book by adding a section, so that the next
reader can get the best experience out of it.</p>
<h2 id="how-to-build-with-intellij"><a class="header" href="#how-to-build-with-intellij">How to build with IntelliJ</a></h2>
<p>When editing the IntelliJ build configuration, here are a few non-default values:</p>
<ul>
<li>You should edit the command. When this book tells you to run <code>cargo embed FLAGS</code>,
You'll need to replace the default value <code>run</code> by the command <code>embed FLAGS</code>,</li>
<li>You should enable &quot;Emulate terminal in output console&quot;. Otherwise, your program will fail to print text to a terminal</li>
<li>You should ensure that the working directory is <code>microbit/src/N-name</code>, with <code>N-name</code> being the directory of the chapter you
are reading. You can not run from the <code>src</code> directory since it contains no cargo file.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meet-your-hardware"><a class="header" href="#meet-your-hardware">Meet your hardware</a></h1>
<p>Let's get familiar with the hardware we'll be working with.</p>
<h2 id="microbit"><a class="header" href="#microbit">micro:bit</a></h2>
<p align="center">
<img title="micro:bit" src="04-meet-your-hardware/../assets/microbit-v2.jpg">
</p>
<p>Here are some of the many components on the board:</p>
<ul>
<li>A <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>.</li>
<li>A number of LEDs, most notably the LED matrix on the back</li>
<li>Two user buttons as well as a reset button (the one next to the USB port).</li>
<li>One USB port.</li>
<li>A sensor that is both a <a href="https://en.wikipedia.org/wiki/Magnetometer">magnetometer</a> and an <a href="https://en.wikipedia.org/wiki/Accelerometer">accelerometer</a></li>
</ul>
<p>Of these components, the most important is the microcontroller (sometimes
shortened to &quot;MCU&quot; for &quot;microcontroller unit&quot;), which is the bigger of the two
black squares sitting on the side of the board with the USB port. The MCU is
what runs your code. You might sometimes read about &quot;programming a board&quot;, when
in reality what we are doing is programming the MCU that is installed on the board.</p>
<p>If you happen to be interested in a more detailed description of the board you
can checkout the <a href="https://tech.microbit.org/hardware/">micro:bit website</a>.</p>
<p>Since the MCU is so important, let's take a closer look at the one sitting on our board.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nordic-nrf52833-the-nrf52-microbit-v2"><a class="header" href="#nordic-nrf52833-the-nrf52-microbit-v2">Nordic nRF52833 (the &quot;nRF52&quot;, micro:bit v2)</a></h1>
<p>Our MCU has 73 tiny metal <strong>pins</strong> sitting right underneath it (it's a so called <a href="https://en.wikipedia.org/wiki/Flat_no-leads_package">aQFN73</a> chip).
These pins are connected to <strong>traces</strong>, the little &quot;roads&quot; that act as the wires connecting
components together on the board. The MCU can dynamically alter the electrical properties of the
pins. This works similarly to a light switch, altering how electrical current flows through a
circuit. By enabling or disabling electrical current to flow through a specific pin, an LED attached
to that pin (via the traces) can be turned on and off.</p>
<p>Each manufacturer uses a different part numbering scheme, but many will allow you to
determine information about a component simply by looking at the part number. Looking at our
MCU's part number we find <code>N52833 QIAAA0 2024AL</code>: you probably cannot see it with your bare
eye, but it is on the chip. (If you have a later revision of MB2, your number may vary
somewhat. This not an issue. The <code>N52833</code> part should be there, though.) The <code>N</code> at the
front hints to us that this is a part manufactured by <a href="https://www.nordicsemi.com/">Nordic Semiconductor</a>.  Looking up
the part number on their website we quickly find the <a href="https://www.nordicsemi.com/products/nrf52833">product page</a>.  There we learn that
our chip's main marketing point is that it is a &quot;Bluetooth Low Energy and 2.4 GHz SoC&quot; (SoC
being short for &quot;System on a Chip&quot;), which explains the RF in the product name since RF is
short for radio frequency.  If we search through the documentation of the chip linked on the
<a href="https://www.nordicsemi.com/products/nrf52833">product page</a> for a bit we find the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf">product specification</a> which contains chapter 10
&quot;Ordering Information&quot; dedicated to explaining the weird chip naming. Here we learn that:</p>
<ul>
<li>The <code>N52</code> is the MCU's series, indicating that there are other <code>nRF52</code> MCUs</li>
<li>The <code>833</code> is the part code</li>
<li>The <code>QI</code> is the package code, short for <code>aQFN73</code></li>
<li>The <code>AA</code> is the variant code, indicating how much RAM and flash memory the MCU has,
in our case 512 kilobyte flash and 128 kilobyte RAM</li>
<li>The <code>A0</code> is the build code, indicating the hardware version (<code>A</code>) as well as the product configuration (<code>0</code>)</li>
<li>The <code>2024AL</code> is a tracking code, hence it might differ on your chip</li>
</ul>
<p>The product specification does of course contain a lot more useful information about the chip: for
example, that the chip is an ARM® Cortex™-M4 32-bit processor.</p>
<h2 id="arm-cortex-m4"><a class="header" href="#arm-cortex-m4">Arm? Cortex-M4?</a></h2>
<p>If our chip is manufactured by Nordic, then who is Arm? And if our chip is the
nRF52833, what is the Cortex-M4?</p>
<p>You might be surprised to hear that while &quot;Arm-based&quot; chips are quite
popular, the company behind the &quot;Arm&quot; trademark (<a href="https://www.arm.com/">Arm Holdings</a>) doesn't
actually manufacture chips for purchase. Instead, their primary business
model is to just <em>design</em> parts of chips. They will then license those designs to
manufacturers, who will in turn implement the designs (perhaps with some of
their own tweaks) in the form of physical hardware that can then be sold.
Arm's strategy here is different from companies like Intel, which both
designs <em>and</em> manufactures their chips.</p>
<p>Arm licenses a bunch of different designs. Their &quot;Cortex-M&quot; family of designs
are mainly used as the core in microcontrollers. For example, the Cortex-M4
(the core our chip is based on) is designed for low cost and low power usage.
The Cortex-M7 is higher cost, but with more features and performance.</p>
<p>Luckily, you don't need to know too much about different types of processors
or Cortex designs for the sake of this book. However, you are hopefully now a
bit more knowledgeable about the terminology of your device. While you are
working specifically with an nRF52833, you might find yourself reading
documentation and using tools for Cortex-M-based chips, as the nRF52833 is
based on a Cortex-M design.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-embedded-terminology"><a class="header" href="#rust-embedded-terminology">Rust Embedded terminology</a></h1>
<p>Before we dive into programming the micro:bit let's have a quick look at the libraries and
terminology that will be important for all the future chapters.</p>
<h2 id="abstraction-layers"><a class="header" href="#abstraction-layers">Abstraction layers</a></h2>
<p>For any fully supported microcontroller/board with a microcontroller, you will usually hear the
following terms being used for their levels of abstraction:</p>
<h3 id="peripheral-access-crate-pac"><a class="header" href="#peripheral-access-crate-pac">Peripheral Access Crate (PAC)</a></h3>
<p>The job of the PAC is to provide a safe (ish) direct interface to the peripherals of the chip,
allowing you to configure every last bit however you want (of course also in wrong ways). Usually
you only ever have to deal with the PAC if either the layers that are higher up don't fulfill your
needs or when you are developing higher-level code for them.  Unsurprisingly, the PAC we are (mostly
implicitly) going to use is for the <a href="https://crates.io/crates/nrf52833-pac">nRF52</a>.</p>
<h3 id="hardware-abstraction-layer-hal"><a class="header" href="#hardware-abstraction-layer-hal">Hardware Abstraction Layer (HAL)</a></h3>
<p>The job of the HAL is to build up on top of the chip's PAC and provide an abstraction that is
actually usable for someone who does not know about all the special behaviour of this chip.  Usually
a HAL abstracts whole peripherals away into single structs that can, for example, be used to send
data around via the peripheral. We are going to use the <a href="https://crates.io/crates/nrf52833-hal">nRF52-hal</a>.</p>
<h3 id="board-support-crate-bsp"><a class="header" href="#board-support-crate-bsp">Board Support Crate (BSP)</a></h3>
<p>(In non-Rust situations this is usually called the Board Support Package, hence the acronym.)</p>
<p>The job of the BSP is to abstract a whole board (such as the micro:bit) away at once. That means it
has to provide abstractions to use both the microcontroller as well as the sensors, LEDs etc. that
might be present on the board. Quite often (especially with custom-made boards) no pre-built BSP
will be available. Instead you will be working with a HAL for the chip and build the drivers for the
sensors either yourself or search for them on <code>crates.io</code>. Luckily for us though, the micro:bit does
have a <a href="https://crates.io/crates/microbit-v2">BSP</a>, so we are going to use that on top of our HAL as well.</p>
<h2 id="unifying-the-layers"><a class="header" href="#unifying-the-layers">Unifying the layers</a></h2>
<p>Next we are going to have a look at a very central piece of software
in the Rust Embedded world: <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>. As its name suggests it
relates to the 2nd level of abstraction we got to know: the HALs.
The idea behind <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> is to provide a set of traits that
describe behaviour which is usually shared across all implementations
of a specific peripheral in all the HALs. For example one would always
expect to have functions that are capable of turning the power on a pin
either on or off: to switch an LED on and off on the board or whatever.</p>
<p><code>embedded-hal</code> allows us to write a driver for some piece of hardware, for example a temperature
sensor, that can be used on any chip for which an implementation of the <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> traits
exists. This is accomplished by writing the driver in such a way that it only relies on the
<a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> traits. Drivers that are written in such a way are called <em>platform-agnostic.</em>
Luckily for us, the drivers we will be getting from <code>crates.io</code> are almost all platform agnostic.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>If you want to learn more about these levels of abstraction, Franz Skarman (a.k.a. <a href="https://github.com/TheZoq2/">TheZoq2</a>) held a
talk about this topic during Oxidize 2020: <a href="https://www.youtube.com/watch?v=vLYit_HHPaY">An Overview of the Embedded Rust Ecosystem</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meet-your-software"><a class="header" href="#meet-your-software">Meet your software</a></h1>
<p>In this chapter we will learn how to build, run and debug some <em>very</em> simple programs. The goal here
is not to get into the details of MB2 Rust programming (yet), but to just familiarize yourself with
the mechanics of the process.</p>
<p>First, a quick note about the conventions used in the rest of this book. We expect you to get
a copy of the whole book with</p>
<pre><code>git clone http://github.com/rust-embedded/discovery-mb2
</code></pre>
<p>The book's &quot;source code&quot; is in <code>discovery-mb2/mdbook/src</code>. You should go there in your copy and look
around a bit. Each chapter directory has both the source Markdown text <em>and</em> the complete source for
all the programs in that chapter. When we refer to some path like <code>src/main.rs</code>, we mean that place
starting from the chapter you are working in. For example, your <code>discovery-mb2</code> has a file called
<code>mdbook/src/05-meet-your-software/examples/init.rs</code>. We will refer to that file as just
<code>examples/init.rs</code> in this chapter.</p>
<p>There are two basic kinds of Rust code: &quot;binary&quot; executable programs, and &quot;library&quot; code. The
library code won't play a huge role in this book. Binary program source code can live in one of
several places:</p>
<ul>
<li>
<p>A program in <code>src/main.rs</code> will be automatically compiled and run by <code>cargo embed</code> or <code>cargo run</code>. No special flags are needed.</p>
</li>
<li>
<p>A program in <code>examples/foo.rs</code> can be compiled and run by <code>cargo embed --example foo</code> or
<code>cargo run --example foo</code>.</p>
</li>
<li>
<p>A program in <code>src/bin/bar.rs</code> can be compiled and run by <code>cargo embed --bin bar</code> or
<code>cargo run --bin bar</code>.</p>
</li>
</ul>
<p>This is confusing, but it's a standard convention of Cargo.</p>
<p>Now let's move on and work with all this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-it"><a class="header" href="#build-it">Build it</a></h1>
<p>The first step is to build our &quot;binary&quot; crate. Because the microcontroller has a different
architecture than your computer we'll have to cross compile. Cross compiling in Rust land is as
simple as passing an extra <code>--target</code> flag to <code>rustc</code>or Cargo. The complicated part is figuring out
the argument of that flag: the <em>name</em> of the target.</p>
<p>As we already know the microcontroller on the micro:bit v2 has a Cortex-M4F processor in it.
<code>rustc</code> knows how to cross-compile to the Cortex-M architecture and provides several different
targets that cover the different processors families within that architecture:</p>
<ul>
<li><code>thumbv6m-none-eabi</code>, for the Cortex-M0 and Cortex-M1 processors</li>
<li><code>thumbv7m-none-eabi</code>, for the Cortex-M3 processor</li>
<li><code>thumbv7em-none-eabi</code>, for the Cortex-M4 and Cortex-M7 processors</li>
<li><code>thumbv7em-none-eabihf</code>, for the Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> processors</li>
<li><code>thumbv8m.main-none-eabi</code>, for the Cortex-M33 and Cortex-M35P processors</li>
<li><code>thumbv8m.main-none-eabihf</code>, for the Cortex-M33<strong>F</strong> and Cortex-M35P<strong>F</strong> processors</li>
</ul>
<p>&quot;Thumb&quot; here refers to a version of the Arm instruction set that has smaller instructions for
reduced code size (it's a pun, see). The <code>hf</code>/<code>F</code> parts have hardware floating point
acceleration. This will make numeric computations involving fractional (&quot;floating decimal point&quot;)
computations much faster.</p>
<p>For the micro:bit v2, we'll want the <code>thumbv7em-none-eabihf</code> target.</p>
<p>Before cross-compiling you have to download a pre-compiled version of the standard library (a
reduced version of it, actually) for your target. That's done using <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<p>You only need to do the above step once; <code>rustup</code> will then update this target (re-installing a new
standard library <code>rust-std</code> component that contains the <code>core</code> library we use) whenever you update
your toolchain. Therefore you can skip this step if you have already added the necessary target
while <a href="05-meet-your-software/../03-setup/verify.html#verifying-cargo-embed">verifying your setup</a>.</p>
<p>With the <code>rust-std</code> component in place you can now cross compile the program using Cargo.  Make sure
you are in the <code>mdbook/src/05-meet-your-software</code> directory in the Git repo, then build. This initial code
is an example, so we compile it as such.</p>
<pre><code class="language-console">$ cargo build --example init
   Compiling semver-parser v0.7.0
   Compiling proc-macro2 v1.0.86
   ...

    Finished dev [unoptimized + debuginfo] target(s) in 33.67s
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Be sure to compile this crate <em>without</em> optimizations. The provided <code>Cargo.toml</code> file and
build command above will ensure optimizations are off as long as you <em>don't</em> pass <code>cargo</code> the
<code>--release</code> flag.</p>
</blockquote>
<p>OK, now we have produced an executable. This executable won't blink any LEDs: it's just a simplified
version that we will build upon later in the chapter.  As a sanity check, let's verify that the
produced executable is actually an ARM binary. (The command below is equivalent to</p>
<pre><code>readelf -h ../../../target/thumbv7em-none-eabihf/debug/examples/init
</code></pre>
<p>on systems that have <code>readelf</code>.)</p>
<pre><code class="language-console">$ cargo readobj --example init -- --file-headers
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x117
  Start of program headers:          52 (bytes into file)
  Start of section headers:          793112 (bytes into file)
  Flags:                             0x5000400
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         21
  Section header string table index: 19
</code></pre>
<p>If your numbers don't exactly match these, don't worry: a lot of this is quite dependent
on the current build environment. </p>
<p>Next, we'll flash the program into our microcontroller.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flash-it"><a class="header" href="#flash-it">Flash it</a></h1>
<p>Flashing is the process of moving our program into the microcontroller's persistent memory. Once
flashed, the microcontroller will execute the flashed program every time it is powered on.</p>
<p>Our program will be the <em>only</em> program in the microcontroller memory.  By this I mean that there's
nothing else running on the microcontroller: no OS, no &quot;daemon&quot;, nothing. Our program has full
control over the device.</p>
<p>Flashing the binary itself is quite simple, thanks to <code>cargo embed</code>.</p>
<p>Before executing that command though, let's look into what it actually does. If you look at the side
of your micro:bit with the USB connector facing upwards, you will notice that there are actually
three black squares on there. The biggest one is a speaker. Another is our MCU we already talked
about… but what purpose does the remaining one serve? This chip is <em>another</em> MCU, an NRF52820 almost
as powerful as the NRF52833 we will be programming! This chip has three main purposes:</p>
<ol>
<li>Enable power and reset control of our NRF52833 MCU from the USB connector.</li>
<li>Provide a serial to USB bridge for our MCU (we will look into that in a later chapter).</li>
<li>Provide an interface for programming and debugging our NRF52833 (this is the relevant purpose for
now).</li>
</ol>
<p>This chip acts as sort of bridge between our computer (to which it is connected via USB) and the MCU
(to which it is connected via traces and communicates with using the SWD protocol). This bridge
enables us to flash new binaries on to the MCU, inspect a program's state via a debugger and do
other useful things.</p>
<p>So lets flash it!</p>
<pre><code class="language-console">$ cargo embed --example init
  (...)
     Erasing sectors ✔ [00:00:00] [####################################################################################################################################################]  2.00KiB/ 2.00KiB @  4.21KiB/s (eta 0s )
 Programming pages   ✔ [00:00:00] [####################################################################################################################################################]  2.00KiB/ 2.00KiB @  2.71KiB/s (eta 0s )
    Finished flashing in 0.608s
</code></pre>
<p>You will notice that <code>cargo-embed</code> does not exit after outputting the last line. This is intended:
you should not close <code>cargo-embed</code>, since we need it in this state for the next step — debugging it!
Furthermore, you will have noticed that <code>cargo build</code> and <code>cargo embed</code> are actually passed the same
flags. This is because <code>cargo embed</code> actually executes the build and then flashes the resulting
binary on to the chip. This means you can leave out the <code>cargo build</code> step in the future if you want
to flash your code right away.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-it"><a class="header" href="#debug-it">Debug it</a></h1>
<p>Let's figure out how to debug our little program. It doesn't really have any interesting bugs yet,
but that's the best kind of program to learn debugging on.</p>
<h2 id="how-does-this-even-work"><a class="header" href="#how-does-this-even-work">How does this even work?</a></h2>
<p>Before we debug our program let's take a moment to quickly understand what is actually happening
here. In the previous chapter we already discussed the purpose of the second chip on the board, as
well as how it talks to our computer, but how can we actually use it?</p>
<p>The little option <code>default.gdb.enabled = true</code> in <code>Embed.toml</code> made <code>cargo embed</code> open a so-called
&quot;GDB stub&quot; after flashing. This is a server that our GDB can connect to and send commands like &quot;set
a breakpoint at address X&quot;. The server can then decide on its own how to handle this command. In the
case of the <code>cargo embed</code> GDB stub it will forward the command via USB to the &quot;debugging probe&quot; on
the second chip. This chip does the job of talking to the MCU for us.</p>
<h2 id="lets-debug"><a class="header" href="#lets-debug">Let's debug!</a></h2>
<p><code>cargo-embed</code> is running in our current shell. We can open a new shell and go back into our project
directory. Once we are there we first have to open the binary in gdb like this:</p>
<pre><code class="language-shell">$ gdb ../../../target/thumbv7em-none-eabihf/debug/examples/init
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Depending on which GDB you installed you will have to use a different command to launch
it. Check out <a href="05-meet-your-software/../03-setup/index.html#tools">chapter 3</a> if you forgot which one it was.</p>
</blockquote>
<p>The <code>../../..</code> in this command is needed, since each example project is in a &quot;workspace&quot; that
contains the entire book. Workspaces have a single shared <code>target</code> directory. Check out <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html#creating-a-workspace">Workspaces
chapter in Rust Book</a> for more.</p>
<blockquote>
<p><strong>NOTE</strong> If <code>cargo-embed</code> prints a lot of warnings here don't worry about it. As of now it does
not fully implement the GDB protocol, and thus might not recognize all the commands your GDB is
sending to it. As long as GDB does not crash, you are fine.</p>
</blockquote>
<p>Next we will have to connect to the GDB stub. It runs on <code>localhost:1337</code> by default so in order to
connect to it run the following:</p>
<pre><code class="language-shell">(gdb) target remote :1337
Remote debugging using :1337
0x00000116 in nrf52833_pac::{{impl}}::fmt (self=0xd472e165, f=0x3c195ff7) at /home/nix/.cargo/registry/src/github.com-1ecc6299db9ec823/nrf52833-pac-0.9.0/src/lib.rs:157
157     #[derive(Copy, Clone, Debug)]
</code></pre>
<p>Next what we want to do is get to the <code>main</code> function of our program.  We will do this by first
setting a breakpoint there and then continuing program execution until we hit the breakpoint:</p>
<pre><code>(gdb) break main
Breakpoint 1 at 0x104: file src/05-meet-your-software/examples/init.rs, line 9.
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) continue
Continuing.

Breakpoint 1, init::__cortex_m_rt_main_trampoline () at src/05-meet-your-software/examples/init.rs:9
9       #[entry]
</code></pre>
<p>Breakpoints can be used to stop the normal flow of a program. The <code>continue</code> command will let the
program run freely <em>until</em> it reaches a breakpoint. In this case, until it reaches the <code>main</code>
function because there's a breakpoint there.</p>
<p>Note that GDB output says &quot;Breakpoint 1&quot;. Remember that our processor can only use a limited amount
of these breakpoints, so it's a good idea to pay attention to these messages. If you happen to run
out of breakpoints, you can list all the current ones with <code>info break</code> and delete desired ones with
<code>delete &lt;breakpoint-num&gt;</code>.</p>
<p>For a nicer debugging experience, we'll be using GDB's Text User Interface (TUI). To enter into that
mode, on the GDB shell enter the following command:</p>
<pre><code>(gdb) layout src
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Apologies Windows users. The GDB shipped with the GNU ARM Embedded Toolchain doesn't
support this TUI mode <code>:-(</code>.</p>
</blockquote>
<p><img src="05-meet-your-software/../assets/gdb-layout-src.png" alt="GDB session" title="GDB TUI" /></p>
<p>GDB's break command does works for more than just function names: it can also break at certain line
numbers.  If we want to break in line 13 we can simply do:</p>
<pre><code>(gdb) break 13
Breakpoint 2 at 0x110: file src/05-meet-your-software/examples/init.rs, line 13.
(gdb) continue
Continuing.

Breakpoint 2, init::__cortex_m_rt_main () at src/05-meet-your-software/examples/init.rs:13
(gdb)
</code></pre>
<p>At any point you can leave the TUI mode using the following command:</p>
<pre><code>(gdb) tui disable
</code></pre>
<p>We are now &quot;on&quot; the <code>_y = x</code> statement; that statement hasn't been executed yet. This means that <code>x</code>
is initialized but <code>_y</code> could contain anything. Let's inspect <code>x</code> using the <code>print</code> command:</p>
<pre><code>(gdb) print x
$1 = 42
(gdb) print &amp;x
$2 = (*mut i32) 0x20003fe8
(gdb)
</code></pre>
<p>As expected, <code>x</code> contains the value <code>42</code>. The command <code>print &amp;x</code> prints the address of the variable
<code>x</code>.  The interesting bit here is that GDB output shows the type of the reference: <code>*mut i32</code>, a
pointer to a mutable <code>i32</code> value.</p>
<p>If we want to continue the program execution line by line, we can do that using the <code>next</code> command.
Let's proceed to the <code>loop {}</code> statement:</p>
<pre><code>(gdb) next
16          loop {}
</code></pre>
<p>And <code>_y</code> should now be initialized.</p>
<pre><code>(gdb) print _y
$5 = 42
</code></pre>
<p>Instead of printing the local variables one by one you can also use the <code>info locals</code> command:</p>
<pre><code>(gdb) info locals
x = 42
_y = 42
(gdb)
</code></pre>
<p>If we use <code>next</code> again on top of the <code>loop {}</code> statement, we'll get stuck because the program will
never pass that statement. Instead, we'll switch to the disassemble view with the <code>layout asm</code>
command and advance one instruction at a time using <code>stepi</code>. You can always switch back into Rust
source code view later by issuing the <code>layout src</code> command again.</p>
<blockquote>
<p><strong>NOTE</strong>: If you used the <code>next</code> or <code>continue</code> command by mistake and GDB got stuck, you can get
unstuck by hitting <code>Ctrl+C</code>.</p>
</blockquote>
<pre><code>(gdb) layout asm
</code></pre>
<p><img src="05-meet-your-software/../assets/gdb-layout-asm.png" alt="GDB session" title="GDB disassemble" /></p>
<p>If you are not using the TUI mode, you can use the <code>disassemble /m</code> command to disassemble the
program around the line you are currently at.</p>
<pre><code>(gdb) disassemble /m
Dump of assembler code for function _ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E:
10      fn main() -&gt; ! {
   0x0000010a &lt;+0&gt;:     sub     sp, #8
   0x0000010c &lt;+2&gt;:     movs    r0, #42 ; 0x2a

11          let _y;
12          let x = 42;
   0x0000010e &lt;+4&gt;:     str     r0, [sp, #0]

13          _y = x;
   0x00000110 &lt;+6&gt;:     str     r0, [sp, #4]

14
15          // infinite loop; just so we don't leave this stack frame
16          loop {}
=&gt; 0x00000112 &lt;+8&gt;:     b.n     0x114 &lt;_ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E+10&gt;
   0x00000114 &lt;+10&gt;:    b.n     0x114 &lt;_ZN12init18__cortex_m_rt_main17h3e25e3afbec4e196E+10&gt;

End of assembler dump.
</code></pre>
<p>See the fat arrow <code>=&gt;</code> on the left side? It shows the instruction the processor will execute next.</p>
<p>If not inside the TUI mode on each <code>stepi</code> command GDB will print the statement and the line number
of the instruction the processor will execute next.</p>
<pre><code>(gdb) stepi
16          loop {}
(gdb) stepi
16          loop {}
</code></pre>
<p>One last trick before we move to something more interesting. Enter the following commands into GDB:</p>
<pre><code>(gdb) monitor reset
(gdb) c
Continuing.

Breakpoint 1, init::__cortex_m_rt_main_trampoline () at src/05-meet-your-software/src/main.rs:9
9       #[entry]
(gdb)
</code></pre>
<p>We are now back at the beginning of <code>main</code>!</p>
<p><code>monitor reset</code> will reset the microcontroller and stop it right at the program entry point.
The following <code>continue</code> command will let the program run freely until it reaches the <code>main</code>
function that has a breakpoint on it.</p>
<p>This combo is handy when you, by mistake, skipped over a part of the program that you were
interested in inspecting. You can easily roll back the state of your program back to its very
beginning.</p>
<blockquote>
<p><strong>The fine print</strong>: This <code>reset</code> command doesn't clear or touch RAM. That memory will retain its
values from the previous run. That shouldn't be a problem though, unless your program behavior
depends on the value of <em>uninitialized</em> variables — but that's the definition of Undefined
Behavior (UB).</p>
</blockquote>
<p>We are done with this debug session. You can end it with the <code>quit</code> command.</p>
<pre><code>(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: $PWD/target/thumbv7em-none-eabihf/debug/meet-your-software, Remote target
Ending remote debugging.
[Inferior 1 (Remote target) detached]
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the default GDB CLI is not to your liking check out <a href="https://github.com/cyrus-and/gdb-dashboard#gdb-dashboard">gdb-dashboard</a>. It uses Python
to turn the default GDB CLI into a dashboard that shows registers, the source view, the assembly
view and other things.</p>
</blockquote>
<p>If you want to learn more about what GDB can do, check out the section <a href="05-meet-your-software/../appendix/2-how-to-use-gdb/">How to use
GDB</a>.</p>
<p>What's next? The high level API I promised.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-it-up"><a class="header" href="#light-it-up">Light it up</a></h1>
<p>We will finish this chapter by making one of the many LEDs on the MB2 light up. In order to get this
task done we will use one of the traits provided by <code>embedded-hal</code>, specifically the <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/digital/v2/trait.OutputPin.html"><code>OutputPin</code></a>
trait which allows us to turn a pin on or off.</p>
<h2 id="the-microbit-leds"><a class="header" href="#the-microbit-leds">The micro:bit LEDs</a></h2>
<p>On the back of the micro:bit you can see a 5x5 square of LEDs, usually called an LED matrix. This
matrix alignment is used so that instead of having to use 25 separate pins to drive every single one
of the LEDs, we can just use 10 (5+5) pins in order to control which column and which row of our
matrix lights up.</p>
<p>Right now we will use the <code>microbit-v2</code> crate to manipulate the LEDs. In the <a href="05-meet-your-software/../06-hello-world/index.html">next chapter</a> we will
go in detail through all of the options available.</p>
<h2 id="actually-lighting-it-up"><a class="header" href="#actually-lighting-it-up">Actually lighting it up!</a></h2>
<p>The code required to light up an LED in the matrix is actually quite simple but it requires a bit of
setup. First take a look at <code>examples/light-it-up.rs</code>; then we can go through it step by step.</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use microbit::board::Board;
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<p>The first few lines until the <code>main</code> function just do some basic imports and setup we mostly looked
at before.  However, the <code>main</code> function looks pretty different to what we have seen up to now.</p>
<p>The first line is related to how most HALs written in Rust work internally.
As discussed before they are built on top of PAC crates which own (in the Rust sense)
all the peripherals of a chip. When we say</p>
<pre><code>let mut board = Board::take().unwrap();
</code></pre>
<p>We take all of these peripherals from the PAC and bind them to a variable. In this specific case we
are not only working with a HAL but with an entire BSP, so this also takes ownership of the Rust
representation of the other chips on the board.</p>
<blockquote>
<p><strong>NOTE</strong>: If you are wondering why we have to call <code>unwrap()</code> here, in theory it is possible for
<code>take()</code> to be called more than once. This would lead to the peripherals being represented by two
separate variables and thus lots of possible confusing behaviour because two variables modify the
same resource. In order to avoid this, PACs are implemented in a way that it would panic if you
tried to take the peripherals twice.</p>
</blockquote>
<p>(Again, if you are confused by all of this, the <a href="05-meet-your-software/../06-hello-world/index.html">next chapter</a> will go through it all again in
greater detail.)</p>
<p>Now we can light the LED connected to <code>row1</code>, <code>col1</code> up by setting the <code>row1</code> pin to high
(i.e. switching it on).  The reason we can leave <code>col1</code> set to low is because of how the LED matrix
circuit works. Furthermore, <code>embedded-hal</code> is designed in a way that every operation on hardware can
possibly return an error, even just toggling a pin on or off. Since that is highly unlikely in our
case, we can just <code>unwrap()</code> the result.</p>
<h2 id="testing-it"><a class="header" href="#testing-it">Testing it</a></h2>
<p>Testing our little program is quite simple. First put it into <code>src/main.rs</code>. Afterwards we simply
have to run the <code>cargo embed</code> command from the last section again, and let it flash just like
before. Then open our GDB and connect to the GDB stub:</p>
<pre><code>$ # Your GDB debug command from the last section
(gdb) target remote :1337
Remote debugging using :1337
cortex_m_rt::Reset () at /home/nix/.cargo/registry/src/github.com-1ecc6299db9ec823/cortex-m-rt-0.6.12/src/lib.rs:489
489     pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
(gdb)
</code></pre>
<p>We now let the program run via the GDB <code>continue</code> command: one of the LEDs on the front of the
micro:bit should light up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>In the last section, you wrote a sort of &quot;Hello World&quot; program. But for embedded programmers, the
&quot;real Hello World&quot; is to blink an LED — any LED — on and off once per second. A program that does
this is commonly known as a &quot;blinky&quot;.</p>
<p>Why blinky? Because this shows that you have enough control of the board you're working with to
perform this simple task. You can get a program loaded onto the machine and running, you can find
and turn on the appropriate pin on the MCU, you can delay for a fixed amount of time. Once you have
this much control, other tasks become much more straightforward.</p>
<p>In previous chapters, you found out several ways to load a program onto your MB2. Now it's just a
question of which pin you turn on and off, and how you delay between these actions.</p>
<p>Let's start by finding out how to work with the needed pins. There's a path you can follow for this
if you know how to read electronic circuit &quot;schematic&quot; diagrams. You can find the <a href="https://github.com/microbit-foundation/microbit-v2-hardware/blob/main/V2.21/MicroBit_V2.2.1_nRF52820%20schematic.PDF">MB2 schematic</a>,
find an LED on that schematic that you want to turn on and off, and find what GPIO pins on the
nRF52833 are attached to that LED. (The MB2 is a bit unusual in this regard: usually an LED is
attached to just one pin that turns it on or off. The LED &quot;display&quot; on the MB2 is hooked up in a
more complicated way to allow turning on and off combinations of LEDs at once: a feature that we
will be using shortly.)</p>
<p>We will work with the LED in the upper-left corner of the MB2 display. Tracing the <code>ROW1</code> and <code>COL1</code>
wires this LED is connected to, we can see that they go to pins on the nRF52833 labeled
<code>AC17</code>/<code>P0.21</code> and <code>B11</code>/<code>AIN4</code>/<code>P0.28</code>. Digging further through the documentation we find that
<code>AC17</code> and <code>B11</code> are the row and column indices of the physical pins (solder balls, really) on the
bottom of the chip — useless to us. <code>AIN4</code> just means that this pin can act as an &quot;Analog Input&quot;,
which is also currently useless to us. (It will come into play later.)</p>
<p>This leaves <code>P0.21</code> and <code>P0.28</code>. These labels correspond to bits in the memory of the nRF52833 that
can be turned on and off to get the LED to light up. Because electronics reasons, if pin <code>P0.21</code> is
turned on (thus outputting 3.3V) and pin <code>P0.28</code> is turned off (thus accepting voltage) the LED will
light up.</p>
<p>But what do we do in software to cause this to occur? We will work at the level of the
<code>nrf52833-hal</code> crate. The Hardware Abstraction Layer (HAL) is a chunk of software designed to make a
particular microcontroller easier to work with. As can be seen from the name, we have one for the
microcontroller on the MB2. It happens to contain everything needed to turn our target LED on.</p>
<p>Take a look at <code>examples/light-up.rs</code> in this chapter's directory, and then try running it.
You could use something fancy like before, but we have it set up so that</p>
<pre><code>cargo run --example light-up
</code></pre>
<p>will load and run your program. That one LED should now be brightly lit!</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let _row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    #[allow(clippy::empty_loop)]
    loop {}
}</code></pre></pre>
<p>Note that we access the Peripheral Access Crate (PAC) for this chip through our HAL crate. There's a
complicated dance needed to get access to our pins. Finally, since we can just initialize the pins
to the right levels, we don't need to set them. Wiggling the pins is a topic for the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toggle-it"><a class="header" href="#toggle-it">Toggle it</a></h1>
<p>Let's turn the LED on and off repeatedly. That's how you make it blink, right?</p>
<p>In <code>examples/fast-blink.rs</code> you'll find the next iteration of our blinky. I've decided to make it
blink the next LED over, while leaving the original LED on. That is an easy change.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let _row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let mut row2 = p0.p0_22.into_push_pull_output(gpio::Level::Low);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    loop {
        row2.set_high().unwrap();
        row2.set_low().unwrap();
    }
}</code></pre></pre>
<p>The <code>embedded-hal</code> crate is being used here to provide the Rust traits needed to set and unset the
LED. This means that this part of the code is portable to any Rust HAL that implements the
<code>embedded-hal</code> traits as ours does.</p>
<p>But wait: neither LED is blinking! The second one is slightly dimmer than the first one, but they
are both solidly on… or are they? Out of the box, the MB2 executes 64 <em>million</em> instructions per
second. Let's assume it takes a few dozen instructions under the hood to turn the LED on or
off. (Maybe possibly that many compiled in debug mode, though way less in release mode. Though the
pins take a while to change state. I don't know.) Anyhow, that second LED is actually turning on and
off hundreds of thousands of times — perhaps millions of times — every second. Your eye just can't
keep up.</p>
<p>We'll need to wait a while between toggles. Turns out waiting is the hardest part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spin-wait"><a class="header" href="#spin-wait">Spin wait</a></h1>
<p>To blink the LED, we need to wait about a half-second between each change. How do we do that?</p>
<p>Well, here's the dumb way. It's not good, but it's a start. Take a look at <code>examples/spin-wait.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm::nop;
use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::{gpio, pac};
use panic_halt as _;

fn wait() {
    for _ in 0..4_000_000 {
        nop();
    }
}

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();
    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let mut row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    loop {
        wait();
        row1.set_high().unwrap();
        wait();
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>Run this with <code>cargo run --release --example spin-wait</code> — the <code>--release</code> is really important here — and
you should see the LED on your MB2 flash on and off <em>about</em> once per second.</p>
<p>Things you might be wondering:</p>
<ul>
<li>
<p><strong>What are those <code>_</code> characters in that number?</strong> Rust allows these in numbers and ignores them.
It's really convenient to make big numbers more readable. Here we are using them as commas (or
whatever the separator is for groups of three digits in your country).</p>
</li>
<li>
<p><strong>If the nRF52833 is running at 64MHz, why is the wait loop iterating only 4M times? Shouldn't it
be 32M?</strong> The wait loop executes several instructions each time through: the <code>nop</code> (see next
section), some bookkeeping, and a branch back to the start of the loop. The code generated is
roughly this for the first <code>wait()</code> call</p>
<pre><code class="language-asm">.LBB1_4:
    adds r3, #1
    nop
    cmp  r3, r2
    bne  .LBB1_4
</code></pre>
<p>and this for the second</p>
<pre><code class="language-asm">.LBB1_6:
    subs	r3, #1
    nop
    bne	.LBB1_6
</code></pre>
<p>This is only three or four instructions, but the backward branch may cost an extra bit.  Notice
that these <em>are not the same:</em> the compiler chooses to emit different instructions for the first
and second wait loops. See &quot;it varies depending&quot; below.</p>
<p>Still, we're executing about 4 instructions per loop iteration. This means that on our 64MHz CPU a
half-second spin should take 64M/2/4 = 8M iterations to complete. So something is slowing us down
by a factor of 2. What? I dunno. This whole thing is terrible.</p>
</li>
<li>
<p><strong>Why is <code>--release</code> so all-important?</strong> Try without it. Notice that the LED is still flashing on
and off, but with a period of <em>many</em> seconds. The wait loop is now unoptimized and is taking many
instructions each time through.</p>
</li>
<li>
<p><strong>What is that <code>nop()</code> call and why is it there?</strong> We shall answer this in the next section.</p>
</li>
<li>
<p><strong>Why do you refer to this as &quot;the dumb way&quot;?</strong></p>
<ul>
<li>
<p><strong>It isn't precise.</strong> Trying to tune that loop to reliably hit exactly 0.5 seconds is… not
really a thing.</p>
</li>
<li>
<p><strong>It varies depending.</strong> Different CPU? Different compilation flags? Different anything really?
Now the timing has changed.</p>
</li>
<li>
<p><strong>It sucks power.</strong> The CPU is running instructions as fast as it can, just to stay in place.
If there's nothing else for it to do, it should quietly sleep until it is needed again. This
doesn't matter much if you have USB power. But if you hook up your MB2 using the battery pack
you'll really feel this.</p>
</li>
</ul>
</li>
</ul>
<p>In the next section, we'll discuss <code>nop()</code>. After that, we'll talk more about the other things about
our blinky that need improving.</p>
<p>For such a simple program, this is a pretty complicated program. That's why we start with blinky.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nop"><a class="header" href="#nop">NOP</a></h1>
<p>You might wonder what that <code>nop()</code> call is doing in the <code>wait()</code> loop in <code>src/bin/spin-wait.rs</code>.</p>
<p>The answer is that it literally does nothing. The <code>nop()</code> function causes the compiler to put a
<code>NOP</code> ARM machine instruction at that point in the program. <code>NOP</code> is a special instruction that
causes the CPU to skip it. To ignore it. To literally do No OPeration with it (hence the name).</p>
<p>So get rid of that line and recompile the program. Don't forget <code>--release</code> mode. Then run it.</p>
<p>We're back to a slightly darker solid LED again. With no loop body, the compiler's optimizer decided
that <code>wait()</code> function wasn't doing anything. So it just removed it for you at compile time. Thanks
optimizer. You have made my wait loop infinitely fast.</p>
<p>How does <code>nop()</code> do its job? Well, if you look at the implementation of <code>nop()</code> you will find
(after a bunch of digging around) that it is implemented like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asm!(&quot;nop&quot;, options(nomem, nostack, preserves_flags));
<span class="boring">}</span></code></pre></pre>
<p>The <code>nop()</code> function is &quot;inlined&quot;, so when you &quot;call&quot; it an actual ARM <code>NOP</code> assembly instruction is
inserted into your program's code at that point. Because details, this <code>NOP</code> will not be removed or
moved around by the compiler: it will stay right there where you put it.</p>
<p>The ability to insert assembly code into your program where needed is sometimes quite important in
embedded programming. Sometime a CPU will have instructions the compiler doesn't know about, but
that you still need in order to use the CPU effectively. Rust's <code>asm!()</code> directive gives you a way
to do that.</p>
<p>Our spin-wait is still terrible. Let's talk about doing better.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>One of the big advantages of a &quot;bare-metal&quot; embedded system is that you control everything that
happens on your machine. This allows you to have really precise control of time: nothing will slow
you down unless you let it.</p>
<p>However, we've seen that if we really want to get time right, we probably need help. Embedded MCUs
like the nRF52833 all provide this kind of help in the form of &quot;timers&quot;. A timer is a peripheral
that, as its name implies, acts like a little clock that keeps very precise track of time.</p>
<p>The nRF52833 contains four timers. If you look at the documentation for the chip, you'll find that
they are pretty complicated to set up and use. Luckily, the HAL provides a wrapper around timers
that makes common uses easy. The most common use of a timer is to delay for a precise amount of
time: just what our <code>wait()</code> function of the previous sections was trying to do.</p>
<p>Take a look at <code>examples/timer-blinky.rs</code>. This code sets up a timer and uses it to delay for 500ms
(0.5s) between each toggle.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use nrf52833_hal::{gpio, pac, timer};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = pac::Peripherals::take().unwrap();

    let p0 = gpio::p0::Parts::new(peripherals.P0);
    let mut row1 = p0.p0_21.into_push_pull_output(gpio::Level::High);
    let _col1 = p0.p0_28.into_push_pull_output(gpio::Level::Low);

    let mut timer0 = timer::Timer::new(peripherals.TIMER0);

    loop {
        timer0.delay_ms(500);
        row1.set_high().unwrap();
        timer0.delay_ms(500);
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>Run this code with <code>cargo run --release --example timer-blinky</code> and time it with a stopwatch. You'll
find that it is exactly one second for each on-off cycle.</p>
<p>Things you might notice:</p>
<ul>
<li>
<p>We need to use the <code>embedded_hal::Delay</code> trait to get the <code>delay_ms()</code> method we're using.</p>
</li>
<li>
<p>As before, we dig the peripheral out of the PAC peripherals struct and give it to the HAL.</p>
</li>
</ul>
<p>Now we have a production-quality blinky. Let's talk a bit about the implications of all this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portability"><a class="header" href="#portability">Portability</a></h1>
<p>(This section is optional. Feel free to skip to the <a href="06-hello-world/board-support-crate.html">next section</a>, where we clean our code up a bit
and call it a day.)</p>
<p>You may wonder whether all this fancy ecosystem is worth its weight. The setup for our blinky is
pretty fancy, and uses a lot of Rust crates and features for such a simple job.</p>
<p>One cool advantage, though, is that our code becomes really portable. On a different board, the
setup may be different, but the actual blinky loop is identical!</p>
<p>Let's take a look at a blinky for the Sipeed Longan Nano. This is a little $5 board that, like the
MB2, is an embedded board with an MCU. Otherwise, it is completely different: different processor
(the GD32VF103, with a RISC-V instruction set entirely unlike the ARM instruction set we're using),
different peripherals, different board. But it has an LED attached to a GPIO pin, so we can blinky
it.</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

use panic_halt as _;
use riscv_rt::entry;
use gd32vf103xx_hal::{pac, prelude::*, delay::McycleDelay};
use embedded_hal::{blocking::delay::DelayMs, digital::v2::OutputPin};

#[entry]
fn main() -&gt; ! {
    let dp = pac::Peripherals::take().unwrap();

    let mut rcu = dp.RCU.configure().ext_hf_clock(8.mhz()).sysclk(108.mhz()).freeze();

    let gpioc = dp.GPIOC.split(&amp;mut rcu);
    let mut led = gpioc.pc13.into_push_pull_output();
    let mut delay = McycleDelay::new(&amp;rcu.clocks);

    loop {
        delay.delay_ms(500);
        led.set_high().unwrap();
        delay.delay_ms(500);
        led.set_low().unwrap();
    }
}</code></pre></pre>
<p>The differences in setup here are partly because different hardware, and partly because this code
uses an older HAL crate that hasn't yet been updated for <code>embedded-hal</code> 1.0. Yet the main loop is
identical as advertised, and the rest of the code is pretty recognizable. Because of the portability
provided by Rust's easy cross-compilation and the embedded Rust ecosystem, blinky is just blinky.</p>
<p>You can find a complete working <a href="https://github.com/pdx-cs-rust/nanoblinky">nanoblinky</a> example on GitHub, if you want to see all the
details or even get your own board and try it yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-support-crate"><a class="header" href="#board-support-crate">Board support crate</a></h1>
<p>Working directly with the PAC and HAL is pretty neat. Most ARM MCUs and many other MCUs that Rust
can compile for have a PAC crate. If you are working with one that does not, writing a PAC crate can
be tedious but is pretty straightforward. Many MCUs that have a PAC crate also have a HAL crate —
again, it's mostly just tedious work to build one if it is absent. Code written at the PAC and HAL
level gives access to the fine details of the MCU.</p>
<p>As we have seen, though, it becomes pretty annoying to keep track of just what is going on at the
interface between our nRF52833 and the rest of our MB2. We have had to read schematics and whatnot
to see how to use our off-board hardware.</p>
<p>A &quot;board support crate&quot; — known in the non-Rust embedded community as a Board Support Package (BSP)
— is a crate built on top of the HAL and PAC for a board to abstract away the details and provide
conveniences. The board support crate we have been working with is the <code>microbit-v2</code> crate.</p>
<p>Let's use <code>microbit-v2</code> to get a final, cleaned up blinky (<code>src/main.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::{delay::DelayNs, digital::OutputPin};
use microbit::hal::{gpio, timer};
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let board = microbit::Board::take().unwrap();

    let mut row1 = board.display_pins.row1.into_push_pull_output(gpio::Level::High);
    let _col1 = board.display_pins.col1.into_push_pull_output(gpio::Level::Low);

    let mut timer0 = timer::Timer::new(board.TIMER0);

    loop {
        timer0.delay_ms(500);
        row1.set_high().unwrap();
        timer0.delay_ms(500);
        row1.set_low().unwrap();
    }
}</code></pre></pre>
<p>In this case, we haven't changed much. Our board support crate has hidden the PAC (for now). More
importantly, it has done so by letting us just use reasonable names for the row and column GPIO pins
for the LED.</p>
<p>The <code>microbit-v2</code> crate provides even fancier support for those &quot;display&quot; LEDs. We will see this
support used soon to do things more fun than blinky.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registers"><a class="header" href="#registers">Registers</a></h1>
<p>This chapter is a technical deep-dive. You can safely <a href="07-registers/../08-led-roulette/index.html">skip it</a> for now and come back to it later if
you like. That said, there's a lot of good stuff in here, so I'd recommend you dive in.</p>
<hr />
<p>It's time to explore what calling <code>display_pins.row1.set_high()</code> does under the hood.</p>
<p>In a nutshell, it just writes to some special memory regions. Go into the <code>07-registers</code> directory
and let's run the starter code statement by statement (<code>src/main.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A magic address!
        const PORT_P0_OUT: u32 = 0x50000504;

        // Turn on the top row
        *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;

        // Turn on the bottom row
        *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;

        // Turn off the top row
        *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);

        // Turn off the bottom row
        *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
    }

    loop {}
}</code></pre></pre>
<p>What's this magic?</p>
<p>The address <code>0x50000504</code> points to a <em>register</em>. A register is a special region of memory that
controls a <em>peripheral</em>. A peripheral is a piece of electronics that sits right next to the
processor within the microcontroller package and provides the processor with extra functionality.
After all, the processor, on its own, can only do math and logic.</p>
<p>This particular register controls General Purpose Input/Output (GPIO) <em>pins</em> (GPIO <em>is</em> a
peripheral) and can be used to <em>drive</em> each of those pins <em>low</em> or <em>high</em>. On the nRF52833, these
pins are organized in</p>
<h2 id="an-aside-leds-digital-outputs-and-voltage-levels"><a class="header" href="#an-aside-leds-digital-outputs-and-voltage-levels">An aside: LEDs, digital outputs and voltage levels</a></h2>
<p>Drive? Pin? Low? High?</p>
<p>A pin is a electrical contact. Our microcontroller has several of them and some of them are
connected to Light Emitting Diodes (LEDs). An LED will emit light when voltage is applied to it.  As
the name implies, an LED also acts as a &quot;diode&quot;. A diode will only let electricity flow in one
direction. Hook an LED up &quot;forwards&quot; and light comes out. Hook it up &quot;backwards&quot; and nothing
happens.</p>
<p align="center">
<img class="white_bg" height=180 title="LED circuit" src="https://upload.wikimedia.org/wikipedia/commons/c/c9/LED_circuit.svg">
</p>
<p>Luckily for us, the microcontroller's pins are connected such that we can drive the LEDs the right
way round. All that we have to do is apply enough voltage across the pins to turn the LED on. The
pins attached to the LEDs are normally configured as <em>digital outputs</em> and can output two different
voltage levels: &quot;low&quot;, 0 Volts, or &quot;high&quot;, 3 Volts. A &quot;high&quot; (voltage) level will turn the LED on
whereas a &quot;low&quot; (voltage) level will turn it off.</p>
<p>These &quot;low&quot; and &quot;high&quot; states map directly to the concept of digital logic. &quot;low&quot; is <code>0</code> or <code>false</code>
and &quot;high&quot; is <code>1</code> or <code>true</code>. This is why this pin configuration is known as digital output.</p>
<hr />
<p>OK. But how can one find out what this register does? Time to RTRM (Read the Reference Manual)!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtrm-reading-the-reference-manual"><a class="header" href="#rtrm-reading-the-reference-manual">RTRM: Reading The Reference Manual</a></h1>
<p>We have previously seen the GPIO pins on the nRF52833. On this chip (and on many others) the GPIO
pins are grouped into <em>ports</em>. There are two ports, Port 0 and Port 1, abbreviated to <code>P0</code> and <code>P1</code>
respectively. The pins within each port are named with numbers starting from 0. Port 0 has 32 pins,
named <code>P0.00</code> to <code>P0.31</code>, and Port 1 has 10 pins, named <code>P1.00</code> to <code>P1.09</code>.</p>
<p>The first thing we have to remember out is which pin is connected to which LED.  We previously did
this by tracing the schematic. That turns out to be hard mode: the required information is in the
MB2 <a href="https://tech.microbit.org/hardware/schematic/#v2-pinmap">pinmap table</a>.</p>
<p>The table says:</p>
<ul>
<li><code>ROW1</code>, the top LED row, is connected to the pin <code>P0.21</code>. <code>P0.21</code> is the short form of: Pin 21 on Port 0.</li>
<li><code>ROW5</code>, the bottom LED row, is connected to the pin <code>P0.19</code>.</li>
</ul>
<p>Up to this point, we know that we want to change the state of the pins <code>P0.21</code> and <code>P0.19</code> to turn
the top and bottom rows on and off. These pins are part of Port 0 so we'll use the <code>P0</code> peripheral
to set them up.</p>
<p>Each peripheral has a register <em>block</em> associated with it. A register block is a collection of
registers allocated in contiguous memory. The address at which the register block starts is known as
its base address. We need to figure out what's the base address of the <code>P0</code> peripheral. That
information is in the following section of the microcontroller <a href="https://docs.nordicsemi.com/bundle/nRF52833_PS_v1.6/resource/nRF52833_PS_v1.6.pdf">Product Specification</a>:</p>
<blockquote>
<p>Section 4.2.4 Instantiation - Page 22</p>
</blockquote>
<p>The table says that base address of the <code>P0</code> register block is <code>0x5000_0000</code>.</p>
<p>Each peripheral also has its own section in the documentation. Each of these sections ends with a
table of the registers that the peripheral's register block contains. For the <code>GPIO</code> family of
peripheral, that table is in:</p>
<blockquote>
<p>Section 6.8.2 Registers - Page 144</p>
</blockquote>
<p><code>OUT</code> is the register which we will be using to set/reset. Its offset value is <code>0x504</code> from the base
address of the <code>P0</code>. We can look up <code>OUT</code> in the reference manual.</p>
<p>That register is specified right under the <code>GPIO</code> registers table:</p>
<blockquote>
<p>Subsection 6.8.2.1 OUT - Page 145</p>
</blockquote>
<p>Anyway, <code>0x5000_0000</code> + <code>0x504</code> = <code>0x50000504</code>. That looks familiar! Finally! </p>
<p>This is the register we were writing to. The documentation says some interesting things. First, this
register can both be written to and read from. Next, the register is a 32-bit piece of memory, and
each bit represents the state of the corresponding pin. That means that bit 19 matches pin 19, for
instance.  Setting the bit to 1 will enable the pin output, and setting it to 0 will reset
it. Furthermore, we can see that all pin outputs are disabled by default, as the reset value of all
bits is 0.</p>
<p>We'll use GDB's <code>examine</code> command: <code>x</code>. Depending on the configuration of your GDB server,
GDB will refuse to read memory that isn't specified. You can disable this behaviour by running:</p>
<pre><code>set mem inaccessible-by-default off
</code></pre>
<p>So here we go. Furst turn off the <code>inaccessible-by-default</code> flag, then set a couple of breakpoints, reset the device and halt.</p>
<pre><code>(gdb) set mem inaccessible-by-default off
(gdb) break 16
Breakpoint 1 at 0x172: file src/07-registers/src/main.rs, line 16.
Note: automatically using hardware breakpoints for read-only addresses.
(gdb) break 19
Breakpoint 2 at 0x17c: file src/07-registers/src/main.rs, line 19.
(gdb) break 22
Breakpoint 3 at 0x184: file src/07-registers/src/main.rs, line 22.
(gdb) break 25
Breakpoint 4 at 0x18c: file src/07-registers/src/main.rs, line 25.
(gdb) monitor reset halt
Resetting and halting target
Target halted
</code></pre>
<p>All right. Let's continue until the first breakpoint, right before line 16, and print the contents
of the register at address <code>0x50000504</code>.</p>
<pre><code>(gdb) c
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:16
16              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;
(gdb) x 0x50000504
0x50000504:     0x00000000
</code></pre>
<p>Ok, we see that the register's value is <code>0x00000000</code> or <code>0</code> at this point. This corresponds with the
data in the product specification, which says that <code>0</code> is the 'reset value' of this register. That
means that once the MCU resets, the register will have <code>0</code> as its value.</p>
<p>Let's go on. This line consists of multiple instructions (reading, bitwise ORing and writing), so we
need to instruct the debugger to continue execution more than once, until we hit the next
breakpoint.</p>
<pre><code>(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x00000174 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:16
16              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 21;
(gdb) c
Continuing.

Breakpoint 2, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:19
19              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;
</code></pre>
<p>We've stopped right before line 19, meaning that line 16 is fully executed at this point. Let's have
a look at the <code>OUT</code> register's contents again:</p>
<pre><code>(gdb) x 0x50000504
0x50000504:     0x00200000
</code></pre>
<p>The value of the <code>OUT</code> register is <code>0x00200000</code> at this point, which is <code>2097152</code> in decimal, or
<code>2^21</code>. That means that bit 21 is set to 1, and the rest of the bits is set to 0. That corresponds
to the code on line 16, which writes <code>1 &lt;&lt; 21</code>, or a 1 shifted left 21 positions, bitwise ORed with
<code>OUT</code>s current value (which was 0), to the <code>OUT</code> register.</p>
<p>Writing <code>1 &lt;&lt; 21</code> (<code>OUT[21]= 1</code>) to <code>OUT</code> sets <code>P0.21</code> <em>high</em>. That turns the top LED row
<em>on</em>. Check that the top row is now indeed lit up.</p>
<pre><code>(gdb) c
Continuing.
</code></pre>
<p>Yeah, I was gonna say that. Now, hit 'c' another time to continue execution up to the next
breakpoint and print its value.</p>
<pre><code>Program received signal SIGINT, Interrupt.
0x0000017e in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:19
19              *(PORT_P0_OUT as *mut u32) |= 1 &lt;&lt; 19;
(gdb) c
Continuing.

Breakpoint 3, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:22
22              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);
(gdb) x 0x50000504
0x50000504:     0x00280000
</code></pre>
<p>On line 19, we've set bit 21 of <code>OUT</code> to 1, keeping bit 19 as is. The result is <code>0x00280000</code>, which
is <code>2621440</code> in decimal, or <code>2^19 + 2^21</code>, meaning that both bit 19 and bit 21 is set to 1.</p>
<p>Writing <code>1 &lt;&lt; 19</code> (<code>OUT[19]= 1</code>) to <code>OUT</code> sets <code>P0.19</code> <em>high</em>. That turns the bottom LED row
<em>on</em>. As such, the bottom row should now be lit up.</p>
<p>The following lines turn the rows off again. First the top row, then the bottom row. This time,
we're doing a bitwise AND operation, combined with a bitwise NOT. We calculate <code>!(1 &lt;&lt; 21)</code>, which
is all bits set to 1, except for bit 21. Next, we bitwise AND that with the current value of <code>OUT</code>,
ensuring that only bit 21 is set to 0, keeping the value of the other bits intact.</p>
<p>Continue execution and check that the reported values of the <code>OUT</code> register matches what you
expect. You can press <code>CTRL+C</code> to pause execution once the device enters the endless loop at the end
of the <code>main</code> function.</p>
<pre><code>(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x00000186 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:22
22              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 21);
(gdb) c
Continuing.

Breakpoint 4, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:25
25              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
(gdb) x 0x50000504
0x50000504:     0x00080000
(gdb) c
Continuing.

Program received signal SIGINT, Interrupt.
0x0000018e in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:25
25              *(PORT_P0_OUT as *mut u32) &amp;= !(1 &lt;&lt; 19);
(gdb) c
Continuing.
^C
Program received signal SIGINT, Interrupt.
0x00000196 in registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:28
28          loop {}
(gdb) x 0x50000504
0x50000504:     0x00000000
</code></pre>
<p>And at this points all LEDs should be turned off again!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misoptimization"><a class="header" href="#misoptimization">(mis)Optimization</a></h1>
<p>Reads/writes to registers are quite special. I may even dare to say that they are embodiment of side
effects. In the previous example we wrote four different values to the same register. If you didn't
know that address was a register, you may have simplified the logic to just write the final value
<code>0x00000000</code> into the register.</p>
<p>Actually, LLVM, the compiler's backend / optimizer, does not know we are dealing with a register and
will merge the writes thus changing the behavior of our program. Let's check that really quick.</p>
<p>First, we'll use cargo objdump to get us the assembly of the build artifacts from both the optimized
and the non-optimized build.</p>
<pre><code># Non-optimized
cargo objdump -- --disassemble --no-show-raw-insn --source &gt; debug.dump
# Optimized
cargo objdump --release -- --disassemble --no-show-raw-insn --source &gt; release.dump
</code></pre>
<p>Let's see what's in there. Specifically, let's try to find the assembly that manipulates the <code>OUT</code>
register.</p>
<p>First, let's have a look at the contents of <code>debug.dump</code>, the assembly from the non-optimized build.
I skipped a bunch and added my comments behind the <code>; &lt;--</code>, indicating the line number in the source
code that corresponds to the instruction.</p>
<pre><code>$ cat debug.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	sub	sp, #0x8
     166:      	bl	0x198 &lt;registers::init::hb6346637538e8ec5&gt; @ imm = #0x2e
     16a:      	movw	r1, #0x504        ; &lt;-- Load lower half of `OUT` register address into register `r1`
     16e:      	movt	r1, #0x5000       ; &lt;-- Load upper half of `OUT` register address into register `r1`
     172:      	str	r1, [sp, #0x4]
     174:      	ldr	r0, [r1]          ; &lt;-- (16) Load value at the address in `r1` into `r0`.
     176:      	orr	r0, r0, #0x200000 ; &lt;-- (16) Bitwise OR the value in `r0` with `0x200000`, and store in `r0`
     17a:      	str	r0, [r1]          ; &lt;-- (16) Store contents of `r0` in memory at address from `r1`
     17c:      	ldr	r0, [r1]          ; &lt;-- (19) Load value at the address in `r1` into `r0`.
     17e:      	orr	r0, r0, #0x80000  ; &lt;-- (19) Bitwise OR the value in `r0` with `0x80000`, and store in `r0`
     182:      	str	r0, [r1]          ; &lt;-- (19) Store contents of `r0` in memory at address from `r1`
     184:      	ldr	r0, [r1]          ; &lt;-- (22) Load value at the address in `r1` into `r0`.
     186:      	bic	r0, r0, #0x200000 ; &lt;-- (22) Bitwise AND the value in `r0` with bitwise complement of `0x200000`, and store in `r0`
     18a:      	str	r0, [r1]          ; &lt;-- (22) Store contents of `r0` in memory at address from `r1`
     18c:      	ldr	r0, [r1]          ; &lt;-- (25) Load value at the address in `r1` into `r0`.
     18e:      	bic	r0, r0, #0x80000  ; &lt;-- (25) Bitwise AND the value in `r0` with bitwise complement of `0x80000`, and store in `r0`
     192:      	str	r0, [r1]          ; &lt;-- (25) Store contents of `r0` in memory at address from `r1`
     194:      	b	0x196 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf+0x36&gt; @ imm = #-0x2
     196:      	b	0x196 &lt;registers::__cortex_m_rt_main::h0b7888ca966441cf+0x36&gt; @ imm = #-0x4
[...]
</code></pre>
<p>As you can see, the non-optimized assembly contains 4 loads, 4 stores, and 4 bit manipulation
instructions.  Those correspond nicely with the code we wrote. Now, let's have a look at the
optimized assembly.</p>
<pre><code>$ cat release.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x17a &lt;registers::init::h4390f1d4f8a071f7&gt; @ imm = #0x12
     168:      	movw	r0, #0x504          ; &lt;-- Load lower half of `OUT` register address into register `r0`
     16c:      	movt	r0, #0x5000         ; &lt;-- Load upper half of `OUT` register address into register `r0`
     170:      	ldr	r1, [r0]                ; &lt;-- (?) Load value at the address in `r0` into `r1`.
     172:      	bic	r1, r1, #0x280000       ; &lt;-- (?) Bitwise AND the value in `r1` with bitwise complement of `0x280000`, and store in `r1`
     176:      	str	r1, [r0]                ; &lt;-- (?) Store contents of `r0` in memory at address from `r0`
     178:      	b	0x178 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485+0x18&gt; @ imm = #-0x4
[...]
</code></pre>
<p>Huh? Just a single load - bit manipulate - store?  The state of the LEDs didn't change this time!
The <code>str</code> instruction is the one that writes a value to the register. Our <em>debug</em> (unoptimized)
program had four of them, one for each write to the register, but the <em>release</em> (optimized) program
only has one.</p>
<p>How do we prevent LLVM from misoptimizing our program? We use <em>volatile</em> operations instead of plain
reads/writes (<code>examples/volatile.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A magic address!
        const PORT_P0_OUT: u32 = 0x50000504;

        // Turn on the top row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out | 1 &lt;&lt; 21);

        // Turn on the bottom row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out | 1 &lt;&lt; 19);

        // Turn off the top row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out &amp; !(1 &lt;&lt; 21));

        // Turn off the bottom row
        let out = ptr::read_volatile(PORT_P0_OUT as *mut u32);
        ptr::write_volatile(PORT_P0_OUT as *mut u32, out &amp; !(1 &lt;&lt; 19));
    }

    loop {}
}</code></pre></pre>
<p>Let's run cargo objdump once again, with optimizations enabled.</p>
<pre><code>cargo objdump -q --release --bin volatile -- --disassemble --no-show-raw-insn  &gt; release.volatile.dump
</code></pre>
<p>All right, now have a look at what's inside:</p>
<pre><code>$ cat release.volatile.dump
[...]
00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x192 &lt;registers::init::h4390f1d4f8a071f7&gt; @ imm = #0x2a
     168:      	movw	r0, #0x504
     16c:      	movt	r0, #0x5000
     170:      	ldr	r1, [r0]
     172:      	orr	r1, r1, #0x200000
     176:      	str	r1, [r0]
     178:      	ldr	r1, [r0]
     17a:      	orr	r1, r1, #0x80000
     17e:      	str	r1, [r0]
     180:      	ldr	r1, [r0]
     182:      	bic	r1, r1, #0x200000
     186:      	str	r1, [r0]
     188:      	ldr	r1, [r0]
     18a:      	bic	r1, r1, #0x80000
     18e:      	str	r1, [r0]
     190:      	b	0x190 &lt;registers::__cortex_m_rt_main::h1f38525e07b97485+0x30&gt; @ imm = #-0x4
[...]
</code></pre>
<p>Hey, look at that! Now we've got our four load - manipulate - store cycles back.
Step through the code once again using GDB to see the volatile operations in action!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0xbaaaaaad-address"><a class="header" href="#0xbaaaaaad-address"><code>0xBAAAAAAD</code> address</a></h1>
<p>Not all the peripheral memory can be accessed. Look at this program (<code>examples/bad.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        ptr::read_volatile(0x5000_A784 as *const u32);
    }

    loop {}
}</code></pre></pre>
<p>This address is close to the <code>OUT</code> address we used before but this address is <em>invalid</em>, in the
sense that there's no register at this address.</p>
<p>Now, let's try it.</p>
<pre><code class="language-console">$ cargo run
(..)
Resetting and halting target
Target halted
(gdb) continue
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main_trampoline () at src/07-registers/src/main.rs:9
9	#[entry]
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:10
10	fn main() -&gt; ! {
(gdb) continue
Continuing.

Breakpoint 3, cortex_m_rt::HardFault_ (ef=0x2001ffb8) at src/lib.rs:1046
1046	    loop {}
(gdb) 
</code></pre>
<p>We tried to do an invalid operation, reading memory that doesn't exist, so the processor raised an
<em>exception</em>: a <em>hardware</em> exception.</p>
<p>In most cases, exceptions are raised when the processor attempts to perform an invalid operation.
Exceptions break the normal flow of a program and force the processor to execute an <em>exception
handler</em>, which is just a function/subroutine.</p>
<p>There are different kind of exceptions. Each kind of exception is raised by different conditions and
each one is handled by a different exception handler.</p>
<p>The <code>registers</code> crate depends on the <code>cortex-m-rt</code> crate which defines a default <em>hard fault</em>
handler, named <code>HardFault_</code>, that handles the &quot;invalid memory address&quot; exception. <code>embed.gdb</code> placed
a breakpoint on <code>HardFault</code>; that's why the debugger halted your program while it was executing the
exception handler.  We can get more information about the exception from the debugger. Let's see:</p>
<pre><code>(gdb) list
1040  #[allow(unused_variables)]
1041	#[doc(hidden)]
1042	#[cfg_attr(cortex_m, link_section = &quot;.HardFault.default&quot;)]
1043	#[no_mangle]
1044	pub unsafe extern &quot;C&quot; fn HardFault_(ef: &amp;ExceptionFrame) -&gt; ! {
1045	    #[allow(clippy::empty_loop)]
1046	    loop {}
1047	}
1048	
1049	#[doc(hidden)]
1050	#[no_mangle]
</code></pre>
<p><code>ef</code> is a snapshot of the program state right before the exception occurred. Let's inspect it:</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x5000a784,
  r1: 0x3,
  r2: 0x2001ff24,
  r3: 0x0,
  r12: 0x1,
  lr: 0x4403,
  pc: 0x43ea,
  xpsr: 0x1000000
}
</code></pre>
<p>There are several fields here but the most important one is <code>pc</code>, the Program Counter register.  The
address in this register points to the instruction that generated the exception. Let's disassemble
the program around the bad instruction.</p>
<pre><code>(gdb) disassemble /m ef.pc
Dump of assembler code for function core::ptr::read_volatile&lt;u32&gt;:
1654	pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T {
   0x000043d2 &lt;+0&gt;:	push	{r7, lr}
   0x000043d4 &lt;+2&gt;:	mov	r7, sp
   0x000043d6 &lt;+4&gt;:	sub	sp, #16
   0x000043d8 &lt;+6&gt;:	str	r0, [sp, #4]
   0x000043da &lt;+8&gt;:	str	r0, [sp, #8]

1655	    // SAFETY: the caller must uphold the safety contract for `volatile_load`.
1656	    unsafe {
1657	        assert_unsafe_precondition!(
   0x000043dc &lt;+10&gt;:	b.n	0x43de &lt;core::ptr::read_volatile&lt;u32&gt;+12&gt;
   0x000043de &lt;+12&gt;:	ldr	r0, [sp, #4]
   0x000043e0 &lt;+14&gt;:	movs	r1, #4
   0x000043e2 &lt;+16&gt;:	bl	0x43f4 &lt;core::ptr::read_volatile::precondition_check&gt;
   0x000043e6 &lt;+20&gt;:	b.n	0x43e8 &lt;core::ptr::read_volatile&lt;u32&gt;+22&gt;

1658	            check_language_ub,
1659	            &quot;ptr::read_volatile requires that the pointer argument is aligned and non-null&quot;,
1660	            (
1661	                addr: *const () = src as *const (),
1662	                align: usize = align_of::&lt;T&gt;(),
1663	            ) =&gt; is_aligned_and_not_null(addr, align)
1664	        );
1665	        intrinsics::volatile_load(src)
   0x000043e8 &lt;+22&gt;:	ldr	r0, [sp, #4]
   0x000043ea &lt;+24&gt;:	ldr	r0, [r0, #0]          ; &lt;-- That's the one!
   0x000043ec &lt;+26&gt;:	str	r0, [sp, #12]
   0x000043ee &lt;+28&gt;:	ldr	r0, [sp, #12]

1666	    }
1667	}
   0x000043f0 &lt;+30&gt;:	add	sp, #16
   0x000043f2 &lt;+32&gt;:	pop	{r7, pc}

End of assembler dump.

</code></pre>
<p>The exception was caused by the <code>ldr r0, [r0, #0]</code> instruction, a read instruction. The instruction
tried to read the memory at the address indicated by the <code>r0</code> <em>CPU register</em>. By the way, a CPU
(processor) register not a memory mapped register; it doesn't have an associated address like, say,
<code>OUT</code>.</p>
<p>Wouldn't it be nice if we could check what the value of the <code>r0</code> register was right at the instant
when the exception was raised? Well, we already did! The <code>r0</code> field in the <code>ef</code> value we printed
before is the value of <code>r0</code> register had when the exception was raised. Here it is again:</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x5000a784,
  r1: 0x3,
  r2: 0x2001ff24,
  r3: 0x0,
  r12: 0x1,
  lr: 0x4403,
  pc: 0x43ea,
  xpsr: 0x1000000
}
</code></pre>
<p><code>r0</code> contains the value <code>0x5000_A784</code> which is the invalid address we called the <code>read_volatile</code>
function with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spooky-action-at-a-distance"><a class="header" href="#spooky-action-at-a-distance">Spooky action at a distance</a></h1>
<p><code>OUT</code> is not the only register that can control the pins of Port E. The <code>OUTSET</code> register also lets
you change the value of the pins, as can <code>OUTCLR</code>. However, <code>ODRSET</code> and <code>OUTCLR</code> don't let you
retrieve the current output status of Port E.</p>
<p><code>OUTSET</code> is documented in:</p>
<blockquote>
<p>Subsection 6.8.2.2. OUTSET - Page 145</p>
</blockquote>
<p>Let's look at below program. The key to this program is <code>fn print_out</code>. This function prints the
current value in <code>OUT</code> to the <code>RTT</code> console (<code>examples/spooky.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use registers::{entry, rprintln};

// Print the current contents of P0.OUT
fn print_out() {
    const P0_OUT: u32 = 0x5000_0504;

    let out = unsafe { ptr::read_volatile(P0_OUT as *const u32) };

    rprintln!(&quot;P0.OUT = {:#08x}&quot;, out);
}

#[entry]
fn main() -&gt; ! {
    registers::init();

    unsafe {
        // A bunch of magic addresses!
        const P0_OUTSET: u32 = 0x5000_0508;
        const P0_OUTCLR: u32 = 0x5000_050C;

        // Print the initial contents of OUT
        print_out();

        // Turn on the top LED row
        ptr::write_volatile(P0_OUTSET as *mut u32, 1 &lt;&lt; 21);
        print_out();

        // Turn on the bottom LED row
        ptr::write_volatile(P0_OUTSET as *mut u32, 1 &lt;&lt; 19);
        print_out();

        // Turn off the top LED row
        ptr::write_volatile(P0_OUTCLR as *mut u32, 1 &lt;&lt; 21);
        print_out();

        // Turn off the bottom LED row
        ptr::write_volatile(P0_OUTCLR as *mut u32, 1 &lt;&lt; 19);
        print_out();
    }

    loop {}
}</code></pre></pre>
<p>You'll see this if you run this program:</p>
<pre><code class="language-console">$ cargo embed
# cargo-embed's console
(..)
15:13:24.055: P0.OUT = 0x000000
15:13:24.055: P0.OUT = 0x200000
15:13:24.055: P0.OUT = 0x280000
15:13:24.055: P0.OUT = 0x080000
15:13:24.055: P0.OUT = 0x000000
</code></pre>
<p>Side effects! Although we are reading the same address multiple times without actually modifying it,
we still see its value change every time <code>OUTSET</code> or <code>OUTCLR</code> is written to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-manipulation"><a class="header" href="#type-safe-manipulation">Type safe manipulation</a></h1>
<p>One of the registers of <code>P0</code>, the <code>IN</code> register, is documented as a read-only register.</p>
<blockquote>
<p>6.8.2.4 IN - Pages 145 and 146</p>
</blockquote>
<p>Note that in the 'Access' column of the table, only the 'R' is given for this register.  We are not
supposed to write to this register or Bad Stuff May Happen.</p>
<p>Registers have different read/write permissions. Some of them are write only, others can be read and
written to and there must be others that are read only.</p>
<p>Directly working with hexadecimal addresses is also error-prone. You already saw that trying to
access an invalid memory address caused an exception which disrupted the execution of our program.</p>
<p>Wouldn't it be nice if we had an API to manipulate registers in a &quot;safe&quot; manner? Ideally, the API
should encode these three points I've mentioned: No messing around with the actual addresses, should
respect read/write permissions and should prevent modification of the reserved parts of a register.</p>
<p>Well, we do! <code>registers::init()</code> actually returns a value that provides a type safe API to
manipulate the registers of the <code>P0</code> and <code>P1</code> ports.</p>
<p>As you may remember: a group of registers associated to a peripheral is called register block, and
it's located in a contiguous region of memory. In this type safe API each register block is modeled
as a <code>struct</code> where each of its fields represents a register. Each register field is a different
newtype over e.g. <code>u32</code> that exposes a combination of the following methods: <code>read</code>, <code>write</code> or
<code>modify</code> according to its read/write permissions. Finally, these methods don't take primitive values
like <code>u32</code>, instead they take yet another newtype that can be constructed using the builder pattern
and that prevent the modification of the reserved parts of the register.</p>
<p>The best way to get familiar with this API is to port our running example to it
(<code>examples/type-safe.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use registers::entry;

#[entry]
fn main() -&gt; ! {
    let (p0, _p1) = registers::init();

    // Turn on the top row
    p0.out.modify(|_, w| w.pin21().set_bit());

    // Turn on the bottom row
    p0.out.modify(|_, w| w.pin19().set_bit());

    // Turn off the top row
    p0.out.modify(|_, w| w.pin21().clear_bit());

    // Turn off the bottom row
    p0.out.modify(|_, w| w.pin19().clear_bit());

    loop {}
}</code></pre></pre>
<p>First thing you notice: There are no magic addresses involved. Instead we use a more human friendly
way, <code>p0.out</code>, to refer to the <code>OUT</code> register in the <code>P0</code> port register block.</p>
<p>The register block has a <a href="https://docs.rs/svd2rust/latest/svd2rust/#modify"><code>modify</code></a> method that takes a closure. Before this closure is called, the
<code>OUT</code> register's value is read and passed to the closure as the <code>r</code> parameter. Given the value of
<code>r</code>, you can manipulate <code>w</code> to the desired new value of the register using its methods. The result
is written to the register once the closure returns. In our case, the current value of the register
is also passed in the <code>w</code> parameter, allowing us to just manipulate <code>w</code> when we want to keep the
rest of the register bits as is.</p>
<p>The <code>modify</code> method is defined for registers that allow both write and read access. If you'd like to
just read a register's value, but not update it, you can use the <a href="https://docs.rs/svd2rust/latest/svd2rust/#read"><code>read</code></a> method. Or, if you simply
want to write a register value without reading, there's the <a href="https://docs.rs/svd2rust/latest/svd2rust/#write"><code>write</code></a> method.</p>
<p>Read-only registers only expose <code>read</code>, and write-only registers only expose <code>write</code>. This prevents
users from accessing a register in a way that's not allowed, and therefore you don't need to wrap
the calls in an <code>unsafe</code> block. And you don't need to figure out the exact register address and bit
positions yourself!</p>
<p>Let's run this program! There's some interesting stuff we can do <em>while</em> debugging the program.</p>
<p><code>p0</code> is a reference to the <code>P0</code> port's register block. <code>print p0</code> will return the base address of
the register block, and <code>print *p0</code> will print its value.</p>
<pre><code>$ cargo run
(..)
Target halted
(gdb) set mem inaccessible-by-default off
(gdb) break main.rs:12
Breakpoint 4 at 0x162: main.rs:12. (2 locations)
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
cortex_m_rt::DefaultPreInit () at src/lib.rs:1058
1058	pub unsafe extern &quot;C&quot; fn DefaultPreInit() {}
(gdb) continue
Continuing.

Breakpoint 1, registers::__cortex_m_rt_main_trampoline () at src/07-registers/src/main.rs:7
7	#[entry]
(gdb) continue
Continuing.

Program received signal SIGINT, Interrupt.
registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:8
8	fn main() -&gt; ! {
(gdb) continue
Continuing.

Breakpoint 4.2, registers::__cortex_m_rt_main () at src/07-registers/src/main.rs:12
12	    p0.out.modify(|_, w| w.pin21().set_bit());
(gdb) print *p0                                               ; ⬅️ Printing `*p0` here!
$1 = nrf52833_pac::p0::RegisterBlock {
  _reserved0: [0 &lt;repeats 1284 times&gt;],
  out: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::out::OUT_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::out::OUT_SPEC&gt;
  },
  outset: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::outset::OUTSET_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::outset::OUTSET_SPEC&gt;
  },
  outclr: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::outclr::OUTCLR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::outclr::OUTCLR_SPEC&gt;
  },
  in_: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::in_::IN_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::in_::IN_SPEC&gt;
  },
  dir: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dir::DIR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dir::DIR_SPEC&gt;
  },
  dirset: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dirset::DIRSET_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dirset::DIRSET_SPEC&gt;
  },
  dirclr: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::dirclr::DIRCLR_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 3513288704
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::dirclr::DIRCLR_SPEC&gt;
  },
  latch: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::latch::LATCH_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::latch::LATCH_SPEC&gt;
  },
  detectmode: nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::detectmode::DETECTMODE_SPEC&gt; {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0
      }
    },
    _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::detectmode::DETECTMODE_SPEC&gt;
  },
  _reserved9: [0 &lt;repeats 472 times&gt;],
  pin_cnf: [nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    } &lt;repeats 11 times&gt;, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 2
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }, nrf52833_pac::generic::Reg&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt; {
      register: vcell::VolatileCell&lt;u32&gt; {
        value: core::cell::UnsafeCell&lt;u32&gt; {
          value: 3
        }
      },
      _marker: core::marker::PhantomData&lt;nrf52833_pac::p0::pin_cnf::PIN_CNF_SPEC&gt;
    }]
}


</code></pre>
<p>All these newtypes and closures sound like they'd generate large, bloated programs. If you actually
compile the program in release mode with <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">LTO</a> enabled, though, you'll see exactly the same
instructions that the &quot;unsafe&quot; version that used <code>write_volatile</code> and hexadecimal addresses had!</p>
<p>Use <code>cargo objdump</code> to grab the assembler code to <code>release.type-safe.dump</code>:</p>
<pre><code class="language-console">cargo objdump -q --release --bin type-safe -- --disassemble --no-show-raw-insn  &gt; release.type-safe.dump
</code></pre>
<p>Then search for <code>main</code> in <code>release.type-safe.dump</code></p>
<pre><code>00000158 &lt;main&gt;:
     158:      	push	{r7, lr}
     15a:      	mov	r7, sp
     15c:      	bl	0x160 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd&gt; @ imm = #0x0

00000160 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd&gt;:
     160:      	push	{r7, lr}
     162:      	mov	r7, sp
     164:      	bl	0x192 &lt;registers::init::hec71dddc40be11b5&gt; @ imm = #0x2a
     168:      	movw	r0, #0x504
     16c:      	movt	r0, #0x5000
     170:      	ldr	r1, [r0]
     172:      	orr	r1, r1, #0x200000
     176:      	str	r1, [r0]
     178:      	ldr	r1, [r0]
     17a:      	orr	r1, r1, #0x80000
     17e:      	str	r1, [r0]
     180:      	ldr	r1, [r0]
     182:      	bic	r1, r1, #0x200000
     186:      	str	r1, [r0]
     188:      	ldr	r1, [r0]
     18a:      	bic	r1, r1, #0x80000
     18e:      	str	r1, [r0]
     190:      	b	0x190 &lt;registers::__cortex_m_rt_main::h0e9b57c6799332fd+0x30&gt; @ imm = #-0x4
</code></pre>
<p>You can validate that this yields the exact same binary as the one with the calls to
<code>ptr::read_volatile</code> and <code>ptr::write_volatile</code>.</p>
<p>The best part of all this is that nobody had to write a single line of code to implement the GPIO
API. All the code was automatically generated from a System View Description (SVD) file using the
<a href="https://crates.io/crates/svd2rust">svd2rust</a> tool. This SVD file is actually an XML file that microcontroller vendors provide and that
contains the register maps of their microcontrollers. The file contains the layout of register
blocks, the base addresses, the read/write permissions of each register, the layout of the
registers, whether a register has reserved bits and lots of other useful information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="led-roulette"><a class="header" href="#led-roulette">LED roulette</a></h1>
<p>Alright, let's build a &quot;real&quot; application. The goal is to get to this display of spinning lights:</p>
<p align="center">
<video src="../assets/roulette_fast.mp4" width="500" loop autoplay/>
</p>
<p>Since working with the LED pins separately is quite annoying (especially if you have to use
basically all of them like here) you can use the <code>microbit-v2</code> BSP crate, discussed previously, to
work with the MB2's LED &quot;display&quot;. It works like this (<code>examples/light-it-all.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use microbit::{board::Board, display::blocking::Display, hal::Timer};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();

    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
    let light_it_all = [
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
    ];

    loop {
        // Show light_it_all for 1000ms
        display.show(&amp;mut timer, light_it_all, 1000);
        // clear the display again
        display.clear();
        timer.delay_ms(1000_u32);
    }
}</code></pre></pre>
<p>The Rust array <code>light_it_all</code> shown in the example contains 1 where the LED is on and 0 where it is
off.  The call to <code>show()</code> takes a timer for the BSP display code to use for delaying, a <em>copy</em> of
the array, and a length of time in milliseconds to show this display before returning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge"><a class="header" href="#the-challenge">The challenge</a></h1>
<p>You are now well armed to face our challenge! Again, your application should look like this:</p>
<p align="center">
<video src="../assets/roulette_fast.mp4" width="500" loop autoplay/>
</p>
<p>If you can't exactly see what's happening here it is in a much slower version:</p>
<p align="center">
<video src="../assets/roulette_slow.mp4" width="500" loop autoplay/>
</p>
<p>If you need a hint, <code>templates/solution.rs</code> provides a mostly-filled-out chunk of code to finish. I
would suggest you try it on your own first, though: it should be doable by now…</p>
<p>Got it?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution"><a class="header" href="#my-solution">My solution</a></h1>
<p>What solution did you come up with?</p>
<p>Here's mine. It's probably one of the simplest (but of course not most beautiful) ways to generate
the required matrix:</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use microbit::{board::Board, display::blocking::Display, hal::Timer};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[rustfmt::skip]
const PIXELS: [(usize, usize); 16] = [
    (0, 0),
    (0, 1),
    (0, 2),
    (0, 3),
    (0, 4),
    (1, 4),
    (2, 4),
    (3, 4),
    (4, 4),
    (4, 3),
    (4, 2),
    (4, 1),
    (4, 0),
    (3, 0),
    (2, 0),
    (1, 0),
];

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();

    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);
    #[rustfmt::skip]
    let mut leds = [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
    ];

    let mut last_led = (0, 0);

    loop {
        for current_led in PIXELS.iter() {
            leds[last_led.0][last_led.1] = 0;
            leds[current_led.0][current_led.1] = 1;
            display.show(&amp;mut timer, leds, 30);
            last_led = *current_led;
        }
    }
}</code></pre></pre>
<p>One more thing! Check that your solution also works when compiled in &quot;release&quot; mode:</p>
<pre><code class="language-console">$ cargo embed --release
</code></pre>
<p>If you want to debug your &quot;release&quot; mode binary you'll have to use a different GDB command:</p>
<pre><code class="language-console">$ gdb ../../../target/thumbv7em-none-eabihf/release/led-roulette
</code></pre>
<p>The Rust compiler modifies the machine instructions generated in a release build (sometimes by a
lot) in order to try to make the code faster or smaller. Unfortunately, GDB has a hard time figuring
out what is going on after this. As a result, debugging release builds with GDB can be difficult.</p>
<p>Binary size is something we should always keep an eye on! How big is your solution? You can check
that using the <code>size</code> command on the release binary:</p>
<pre><code class="language-console">$ cargo size --release -- -A
    Finished release [optimized + debuginfo] target(s) in 0.02s
led-roulette  :
section              size        addr
.vector_table         256         0x0
.text                6332       0x100
.rodata               648      0x19bc
.data                   0  0x20000000
.bss                 1076  0x20000000
.uninit                 0  0x20000434
.debug_loc           9036         0x0
.debug_abbrev        2754         0x0
.debug_info         96460         0x0
.debug_aranges       1120         0x0
.debug_ranges       11520         0x0
.debug_str          71325         0x0
.debug_pubnames     32316         0x0
.debug_pubtypes     29294         0x0
.ARM.attributes        58         0x0
.debug_frame         2108         0x0
.debug_line         19303         0x0
.comment              109         0x0
Total              283715
</code></pre>
<p>Your numbers may differ somewhat depending on how your code is built: this is OK.</p>
<p>Know how to read this output? The <code>text</code> section contains the program instructions. The <code>rodata</code>
section contains read-only data stored with the program instructions. The <code>data</code> and <code>bss</code> sections
contain variables statically allocated in RAM (<code>static</code> variables).  If you remember the
specification of the microcontroller on your micro:bit, you should notice that its flash memory is
less than double the size of this extremely simple binary: can this be right?  As we can see from
the size statistics most of the binary is actually made up of debugging related sections. However,
those are not flashed to the microcontroller at any time — after all they aren't relevant for the
execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-communication"><a class="header" href="#serial-communication">Serial communication</a></h1>
<a href="https://en.wikipedia.org/wiki/File:Serial_port.jpg">
<p align="center">
<img height="240" title="Standard serial port connector DE-9" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Serial_port.jpg/800px-Serial_port.jpg"/>
</p>
</a>
<p align="center">
<em>This is what we'll be using. I hope your computer has one!</em>
</p>
<p>Nah, don't worry. This connector, the DE-9, went out of fashion on PCs quite some time ago; it got
replaced by the Universal Serial Bus (USB). We won't be dealing with the DE-9 connector itself but
with the communication protocol that this cable is/was usually used for.</p>
<p>So what's this <a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication"><em>serial communication</em></a>? It's an <em>asynchronous</em> communication protocol where
two devices exchange data <em>serially</em>, as in one bit at a time, using two data lines (plus a common
ground). The protocol is asynchronous in the sense that neither of the shared lines carries a clock
signal. Instead, both parties must agree on how fast data will be sent along the wire <em>before</em> the
communication occurs. This protocol allows <em>duplex</em> communication as data can be sent from A to B
and from B to A simultaneously.</p>
<p>We'll be using this protocol to exchange data between the microcontroller and your computer. Now you
might be asking yourself why exactly we aren't using RTT for this like we did before. RTT is a
protocol that is meant to be used solely for debugging. You will most definitely not be able to find
a device that actually uses RTT to communicate with some other device in production. However, serial
communication is used quite often. For example some GPS receivers send the positioning information
they receive via serial communication. In addition RTT, like many debugging protocols, is slow even
compared to serial transfer rates.</p>
<p>The next practical question you probably want to ask is: How fast can we send data through this
protocol?</p>
<p>This protocol works with frames. Each frame has one <em>start</em> bit, 5 to 9 bits of payload (data) and 1
to 2 <em>stop bits</em>. The speed of the protocol is known as <em>baud rate</em> and it's quoted in bits per
second (bps). Common baud rates are: 9600, 19200, 38400, 57600 and 115200 bps.</p>
<p>To actually answer the question: With a common configuration of 1 start bit, 8 bits of data, 1 stop
bit and a baud rate of 115200 bps one can, in theory, send 11,520 frames per second. Since each one
frame carries a byte of data, that results in a data rate of 11.52 KB/s. In practice, the data rate
will probably be lower because of processing times on the slower side of the communication (the
microcontroller).</p>
<p>Today's computers don't usually support the serial communication protocol, and even if they do the
voltage they use, ±5..12V, may be higher than the micro:bit will accept and may result in damaging
it. You can't directly connect your computer to the microcontroller. You <em>can</em> buy very inexpensive
USB←→serial converters that will support the 0..3V most modern microntroller boards need. While a
serial converter is not necessary for the MB2, as shown below, it can be handy for inexpensive
boards that have few communications options other than serial.)</p>
<p>The debug probe on the micro:bit itself can act as a USB←→serial converter. This means that the
converter will sit between the two and expose a serial interface to the microcontroller and a USB
interface to your computer. The microcontroller will see your computer as another serial device and
your computer will see the microcontroller as a virtual serial device.</p>
<p>Now, let's get familiar with the serial module and the serial communication tools that your OS
offers. Pick a route:</p>
<ul>
<li><a href="09-serial-communication/nix-tooling.html">Linux/UNIX</a></li>
<li><a href="09-serial-communication/windows-tooling.html">Windows</a></li>
</ul>
<p>For MacOS check out the Linux documentation, although your experience may differ somewhat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-usbserial-tooling"><a class="header" href="#linux-usbserial-tooling">Linux USB←→serial tooling</a></h1>
<p>The micro:bit's USB emulated serial device shows up in Linux when youconnect the MB2 to a Linux USB
port.</p>
<h2 id="connecting-the-microbit-board"><a class="header" href="#connecting-the-microbit-board">Connecting the micro:bit board</a></h2>
<p>If you connect the micro:bit board to your computer you should see a new TTY device appear in
<code>/dev</code>.</p>
<pre><code class="language-console">$ sudo dmesg -T | tail | grep -i tty
[63712.446286] cdc_acm 1-1.7:1.1: ttyACM0: USB ACM device
</code></pre>
<p>This is the USB←→serial device. On Linux, it's named <code>tty</code> (for &quot;TeleTYpe&quot;, believe it or not).  It
should show up as <code>ttyACM0</code>, or maybe <code>ttyUSB0</code>. If other &quot;ACM&quot; devices are plugged in, the number
will be higher.  (On Mac OS <code>ls /dev/cu.usbmodem*</code> will show the serial device.)</p>
<p>But what exactly is <code>ttyACM0</code>? It's a file of course!  Everything is a file in Unix:</p>
<pre><code>$ ls -l /dev/ttyACM0
crw-rw----+ 1 root plugdev 166, 0 Jan 21 11:56 /dev/ttyACM0
</code></pre>
<p>Note that you will need to be either running as <code>root</code> (not advised) or a member of the group
<code>plugdev</code> to read and write this device. You can then send out data by simply writing to this file:</p>
<pre><code class="language-console">$ echo 'Hello, world!' &gt; /dev/ttyACM0
</code></pre>
<p>You should see the orange LED on the micro:bit, right next to the USB port, blink for a moment,
whenever you enter this command.</p>
<h2 id="minicom"><a class="header" href="#minicom">minicom</a></h2>
<p>We'll use the program <code>minicom</code> to interact with the serial device using the keyboard.</p>
<p>We must configure <code>minicom</code> before we use it. There are quite a few ways to do that but we'll use a
<code>.minirc.dfl</code> file in the home directory. Create a file in <code>~/.minirc.dfl</code> with the following
contents:</p>
<pre><code class="language-console">$ cat ~/.minirc.dfl
pu baudrate 115200
pu bits 8
pu parity N
pu stopbits 1
pu rtscts No
pu xonxoff No
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Make sure this file ends in a newline! Otherwise, <code>minicom</code> will fail to read the last
line.</p>
</blockquote>
<p>That file should be straightforward to read (except for the last two lines), but nonetheless let's
go over it line by line:</p>
<ul>
<li><code>pu baudrate 115200</code>. Sets baud rate to 115200 bps.</li>
<li><code>pu bits 8</code>. 8 bits per frame.</li>
<li><code>pu parity N</code>. No &quot;parity check bit&quot;, which would be used for error detection.</li>
<li><code>pu stopbits 1</code>. 1 stop bit.</li>
<li><code>pu rtscts No</code>. No hardware flow control.</li>
<li><code>pu xonxoff No</code>. No software flow control.</li>
</ul>
<p>Once that's in place, we can launch <code>minicom</code> on our ACM device, for example:</p>
<pre><code class="language-console">$ minicom -D /dev/ttyACM0 -b 115200
</code></pre>
<p>This tells <code>minicom</code> to open the serial device at <code>/dev/ttyACM0</code> and set its
baud rate to 115200. A text-based user interface (TUI) will pop out.</p>
<p align="center">
<img title="minicom" src="09-serial-communication/../assets/minicom.png">
</p>
<p>You can now send data using the keyboard! Go ahead and type something. Note that
the text UI will <em>not</em> echo back what you type. If you pay attention to the yellow LED
on top of the micro:bit though, you will notice that it blinks whenever you type something.</p>
<h2 id="minicom-commands"><a class="header" href="#minicom-commands"><code>minicom</code> commands</a></h2>
<p><code>minicom</code> exposes commands via keyboard shortcuts. On Linux, the shortcuts start with <code>Ctrl+A</code>. (On
Mac, the shortcuts start with the <code>Meta</code> key.) Some useful commands below:</p>
<ul>
<li><code>Ctrl+A</code> + <code>Z</code>. Minicom Command Summary</li>
<li><code>Ctrl+A</code> + <code>C</code>. Clear the screen</li>
<li><code>Ctrl+A</code> + <code>X</code>. Exit and reset</li>
<li><code>Ctrl+A</code> + <code>Q</code>. Quit with no reset</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> Mac users: In the above commands, replace <code>Ctrl+A</code> with <code>Meta</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-tooling"><a class="header" href="#windows-tooling">Windows tooling</a></h1>
<p>Start by unplugging your micro:bit.</p>
<p>Before plugging the micro:bit back in, run the following command on the terminal:</p>
<pre><code class="language-console">$ mode
</code></pre>
<p>It will print a list of devices that are connected to your computer. The ones that start with <code>COM</code>
in their names are serial devices. This is the kind of device we'll be working with. Take note of
all the <code>COM</code> ports' <code>mode</code> outputs <em>before</em> plugging the serial module.</p>
<p>Now, plug in the micro:bit and run the <code>mode</code> command again. If you see a new
<code>COM</code> port appear on the list, then that's the COM port assigned to the
serial functionality on the micro:bit.</p>
<p>Now launch <code>putty</code>. A GUI will pop out.</p>
<p align="center">
<img title="PuTTY settings" src="09-serial-communication/../assets/putty-settings.png" width="500" />
</p>
<p>On the starter screen, which should have the &quot;Session&quot; category open, pick &quot;Serial&quot; as the
&quot;Connection type&quot;. On the &quot;Serial line&quot; field enter the <code>COM</code> device you got on the previous step,
for example <code>COM3</code>.</p>
<p>Next, pick the &quot;Connection/Serial&quot; category from the menu on the left. On this new view, make sure
that the serial port is configured as follows:</p>
<ul>
<li>&quot;Speed (baud)&quot;: 115200</li>
<li>&quot;Data bits&quot;: 8</li>
<li>&quot;Stop bits&quot;: 1</li>
<li>&quot;Parity&quot;: None</li>
<li>&quot;Flow control&quot;: None</li>
</ul>
<p>Finally, click the Open button. A console will show up now:</p>
<p align="center">
<img title="PuTTY console" src="09-serial-communication/../assets/putty-console.png" width="500" />
</p>
<p>If you type on this console, the yellow LED on top of the micro:bit will blink. Each keystroke
should make the LED blink once. Note that the console won't echo back what you type so the screen
will remain blank.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<p>Our microcontroller (like most) has a peripheral called a UART (for &quot;Universal Asynchronous
Receiver/Transmitter). This peripheral can be configured to work with several serial communication
protocols. The peripheral we will be working with is named UARTE (for &quot;UART with Easy DMA&quot;, a topic
outside the scope of this chapter).</p>
<p>Throughout this chapter, we'll use serial communication to exchange information between the
microcontroller and your computer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-a-single-byte"><a class="header" href="#send-a-single-byte">Send a single byte</a></h1>
<p>Our first task will be to send a single byte from the microcontroller to the computer over the
serial connection.</p>
<p>In order to do that we will use the following snippet (this one is already in
<code>10-uart/examples/send-byte.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::{
    hal::uarte,
    hal::uarte::{Baudrate, Parity},
};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    serial.write(b'X').unwrap();
    serial.flush().unwrap();

    loop {
        wfi();
    }
}</code></pre></pre>
<p>You might notice that one of the libraries used here, the <code>serial_setup</code> module, is not from
<code>crates.io</code>, but was written for this project. The purpose of <code>serial_setup</code> is to provide a nice
wrapper around the UARTE peripheral. If you want, you can check out what exactly the module does,
but it is not required to understand this chapter in general.</p>
<p>We'll next discuss the initialization of UARTE. The UARTE is initialized with this piece of code:</p>
<pre><code class="language-rs">uarte::Uarte::new(
    board.UARTE0,
    board.uart.into(),
    Parity::EXCLUDED,
    Baudrate::BAUD115200,
);
</code></pre>
<p>This function takes ownership of the UARTE peripheral representation in Rust (<code>board.UARTE0</code>) and
the TX/RX pins on the board (<code>board.uart.into()</code>) so nobody else can mess with either the UARTE
peripheral or our pins while we are using them. After that we pass two configuration options to the
constructor: the baudrate (that one should be familiar) as well as an option called &quot;parity&quot;. Parity
is a way to allow serial communication lines to check whether the data they received was corrupted
during transmission. We don't want to use that here so we simply exclude it.  Then we wrap it up in
the <code>UartePort</code> type so we can use it.</p>
<p>After the initialization, we send our <code>X</code> via the newly created uart instance. These serial
functions are &quot;blocking&quot;: they wait for the data to be sent before returning. This is not always
what is wanted: the microcontroller can do a lot of work while waiting for the byte to go out on the
wire. However, in our case it is convenient and we didn't have other work to do anyway.</p>
<p>Last but not least, we <code>flush()</code> the serial port. This is because the UARTE may decide to buffer
output until it has received a certain number of bytes to send.  Calling <code>flush()</code> forces it to
write the bytes it currently has right now instead of waiting for more.</p>
<h2 id="testing-it-1"><a class="header" href="#testing-it-1">Testing it</a></h2>
<p>Before flashing this you should make sure to start your minicom/PuTTY as the data we receive via our
serial communication is not backed up or anything: we have to view it live. Once your serial monitor
is up you can flash the program just like in chapter 5:</p>
<pre><code>$ cargo embed --example send-byte
  (...)
</code></pre>
<p>And after the flashing is finished, you should see the character <code>X</code> show up on your minicom/PuTTY
terminal, congrats!</p>
<p>If you missed it, you can hit the reset button on the back of the MB2. This will cause the program
to start from the beginning and send an <code>X</code> again.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-a-string"><a class="header" href="#send-a-string">Send a string</a></h1>
<p>The next task will be to send a whole string from the microcontroller to your computer.</p>
<p>I want you to send the string <code>&quot;The quick brown fox jumps over the lazy dog.&quot;</code> from the microcontroller to
your computer.</p>
<p>It's your turn to write the program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naive-approach-and-write"><a class="header" href="#naive-approach-and-write">Naive approach and <code>write!</code></a></h1>
<h2 id="naive-approach"><a class="header" href="#naive-approach">Naive approach</a></h2>
<p>You probably came up with a program similar to the following (<code>examples/naive-send-string.rs</code>):</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    for byte in b&quot;The quick brown fox jumps over the lazy dog.\r\n&quot;.iter() {
        serial.write(*byte).unwrap();
    }
    serial.flush().unwrap();

    loop {
        wfi();
    }
}
</code></pre>
<p>While this is a perfectly valid implementation, at some point you might want to have all the nice
perks of <code>print!</code> such as argument formatting and so on. If you are wondering how to do that, read
on.</p>
<h2 id="write-and-corefmtwrite"><a class="header" href="#write-and-corefmtwrite"><code>write!</code> and <code>core::fmt::Write</code></a></h2>
<p>The <code>core::fmt::Write</code> trait allows us to use any struct that implements it in basically the same
way as we use <code>print!</code> in the <code>std</code> world.  In this case, the <code>Uart</code> struct from the <code>nrf</code> HAL does
implement <code>core::fmt::Write</code> so we can refactor our previous program into this
(<code>examples/send-string.rs</code>):</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use core::fmt::Write;
use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    write!(serial, &quot;The quick brown fox jumps over the lazy dog.\r\n&quot;).unwrap();
    serial.flush().unwrap();

    loop {
        wfi();
    }
}
</code></pre>
<p>If you flash this program onto your micro:bit, you'll see that it is functionally equivalent to the
iterator-based program you came up with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receive-a-single-byte"><a class="header" href="#receive-a-single-byte">Receive a single byte</a></h1>
<p>So far we can send data from the microcontroller to your computer. It's time to try the opposite:
receiving data from your computer (<code>examples/receive-byte.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::hal::uarte::{self, Baudrate, Parity};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    loop {
        let byte = serial.read().unwrap();
        rprintln!(&quot;{}&quot;, byte);
    }
}</code></pre></pre>
<p>The only part that changed, compared to our send byte program, is the loop at the end of
<code>main()</code>. Here we use the <code>serial.read()</code> function in order to wait until a byte is available and
read it. Then we print that byte into our RTT debugging console to see whether stuff is actually
arriving.</p>
<p>Note that if you flash this program and start typing characters inside <code>minicom</code> to send them to
your microcontroller you'll only be able to see numbers inside your RTT console since we are not
converting the <code>u8</code> we received into an actual <code>char</code>.  Since the conversion from <code>u8</code> to <code>char</code> is
quite simple, I'll leave this task to you if you really do want to see the characters inside the RTT
console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="echo-server"><a class="header" href="#echo-server">Echo server</a></h1>
<p>Let's merge transmission and reception into a single program and write an echo server. An echo
server sends back to the client the same text it receives. For this application, the microcontroller
will be the server and you and your computer will be the client.</p>
<p>This should be straightforward to implement. (hint: do it byte by byte)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-a-string"><a class="header" href="#reverse-a-string">Reverse a string</a></h1>
<p>Alright, next let's make the server more interesting by having it respond to the client with the
reverse of the text that they sent. The server will respond to the client every time they press the
ENTER key. Each server response will be in a new line.</p>
<p>This time you'll need a buffer; you can use <a href="https://docs.rs/heapless/latest/heapless/struct.Vec.html"><code>heapless::Vec</code></a>. Here's the starter code:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_rt::entry;
use core::fmt::Write;
use heapless::Vec;
use rtt_target::rtt_init_print;
use panic_rtt_target as _;

use microbit::{
    hal::prelude::*,
    hal::uarte,
    hal::uarte::{Baudrate, Parity},
};

mod serial_setup;
use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();

    loop {
        buffer.clear();

        // TODO Receive a user request. Each user request ends with ENTER
        // NOTE `buffer.push` returns a `Result`. Handle the error by responding
        // with an error message.

        // TODO Send back the reversed string
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-1"><a class="header" href="#my-solution-1">My solution</a></h1>
<p>You will find my solution in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::fmt::Write;
use cortex_m_rt::entry;
use heapless::Vec;
use microbit::hal::uarte::{self, Baudrate, Parity};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;
use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut serial = {
        let serial = uarte::Uarte::new(
            board.UARTE0,
            board.uart.into(),
            Parity::EXCLUDED,
            Baudrate::BAUD115200,
        );
        UartePort::new(serial)
    };

    // A buffer with 32 bytes of capacity
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();

    loop {
        buffer.clear();

        loop {
            // We assume that the receiving cannot fail
            let byte = serial.read().unwrap();

            if buffer.push(byte).is_err() {
                write!(serial, &quot;error: buffer full\r\n&quot;).unwrap();
                break;
            }

            if byte == b'\r' {
                for byte in buffer.iter().rev().chain(&amp;[b'\n', b'\r']) {
                    serial.write(*byte).unwrap();
                }
                break;
            }
        }
        serial.flush().unwrap()
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i2c"><a class="header" href="#i2c">I2C</a></h1>
<p>We just saw the UART serial communication format. UART serial is widely used because it is simple
and has been around almost forever. (Remember how the host device is called a &quot;tty&quot; for &quot;TeleTYpe&quot;?
Yeah, that.) This ubiquity and simplicity makes it a popular choice for simple communications.</p>
<p>Because of hardware limitations on line length <em>vs</em> signal quality and because of difficulty of
accurate decoding, UART serial typically caps out at about 115200 baud under ideal conditions. A
UART serial port has both low bandwidth (11.5KB/s) and high latency (87µs/byte).</p>
<p>UART serial is point-to-point: there is no way to connect three or more devices to the same wire,
and each wire requires a dedicated hardware device on each end.</p>
<p>The good news (and the bad news) is that there are <em>plenty</em> of other hardware-assisted serial
communication protocols in the embedded space that overcome these limitations. Some of them are
widely used in digital sensors.</p>
<p>The micro:bit board we are using has two motion sensors in it: an accelerometer and a magnetometer.
Both of these sensors are packaged into a single component and can be accessed via an I2C bus.</p>
<p>I2C is pronounced &quot;EYE-SQUARED-CEE&quot; and stands for Inter-Integrated Circuit. I2C is a <em>synchronous</em>
serial <em>bus</em> communication protocol: it uses two lines to exchange data: a data line (SDA) and a
clock line (SCL). The clock line is used to synchronize the communication. Synchronous serial can
run faster and more reliably than async serial. I2C devices have <em>bus addresses</em>: the hardware
implementation allows sending bytes to a particular device, with other devices connected to the same
wires ignoring this communication.</p>
<p align="center">
<img class="white_bg" height=360 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/0/04/I2C_controller-target.svg" />
</p>
<p>I2C uses a <em>controller</em>/<em>target</em> model: the controller is the device that <em>starts</em> and drives the
communication with a target device. Several devices can be connected to the same bus at the same
time, and can choose to act either as a controller or as a target. A controller device can
communicate with a specific target device by first broadcasting the target address to the bus. This
address can be 7 bits or 10 bits long.  Once a controller has started a communication with a target,
no device is other than the controller and target is allowed to transmit on the bus until the
controller ends the communication.</p>
<blockquote>
<p><strong>NOTE</strong> &quot;Controller/target&quot; was formerly referred to as &quot;master/slave&quot;. You may still see that in
literature or as labeling on boards. This terminology is now deprecated both in official standards
and newer documents, but is used in the Nordic manual for our nRF52833 part and in some embedded
Rust documentation.</p>
</blockquote>
<p>The clock line determines how fast data can be exchanged. The MB2 I2C interface can operate at
speeds of 100, 250 or 400 Kbps. With other devices even faster modes are possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-protocol"><a class="header" href="#general-protocol">General protocol</a></h1>
<p>The I2C protocol is more elaborate than the serial communication protocol because it has to support
communication between several devices. Let's see how it works using examples:</p>
<h2 id="controller--target"><a class="header" href="#controller--target">Controller → Target</a></h2>
<p>If the Controller wants to send data to the Target:</p>
<p align="center">
  <img class="white_bg" height=360 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/0/04/I2C_controller-target.svg" />
</p>
<ol>
<li>Controller: Broadcast START</li>
<li>C: Broadcast target address (7 bits) + the R/W (8th) bit set to WRITE</li>
<li>Target: Responds ACK (ACKnowledgement)</li>
<li>C: Send one byte</li>
<li>T: Responds ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>C: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The target address could have been 10 bits instead of 7 bits long. Nothing else would have
changed.</p>
</blockquote>
<h2 id="controller--target-1"><a class="header" href="#controller--target-1">Controller ← Target</a></h2>
<p>If the controller wants to read data from the target:</p>
<p align="center">
<img class="white_bg" height=360 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/0/04/I2C_controller-target.svg" />
</p>
<ol>
<li>C: Broadcast START</li>
<li>C: Broadcast target address (7 bits) + the R/W (8th) bit set to READ</li>
<li>T: Responds with ACK</li>
<li>T: Send byte</li>
<li>C: Responds with ACK</li>
<li>Repeat steps 4 and 5 zero or more times</li>
<li>C: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The target address could have been 10 bits instead of 7 bits long. Nothing else would
have changed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsm303agr"><a class="header" href="#lsm303agr">LSM303AGR</a></h1>
<p>Both of the motion sensors on the micro:bit, the magnetometer and the accelerometer, are packaged in
a single component: the LSM303AGR integrated circuit. These two sensors can be accessed via an I2C
bus. Each sensor behaves like an I2C target and has a <em>different</em> address.</p>
<p>Each sensor has its own memory where it stores the results of sensing its environment. Our
interaction with these sensors will mainly involve reading their memory.</p>
<p>The memory of these sensors is modeled as byte addressable registers. These sensors can be
configured too; that's done by writing to their registers. So, in a sense, these sensors are very
similar to the peripherals <em>inside</em> the microcontroller. The difference is that their registers are
not mapped into the microcontrollers' memory. Instead, their registers have to be accessed via the
I2C bus.</p>
<p>The main source of information about the LSM303AGR is its <a href="https://www.st.com/resource/en/datasheet/lsm303agr.pdf">Data Sheet</a>. Read through it to see how
one can read the sensors' registers. That part is in:</p>
<blockquote>
<p>Section 6.1.1 I2C Operation - Page 38 - LSM303AGR Data Sheet</p>
</blockquote>
<p>The other part of the documentation relevant to this book is the description of the registers. That
part is in:</p>
<blockquote>
<p>Section 8 Register description - Page 46 - LSM303AGR Data Sheet</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-a-single-register"><a class="header" href="#read-a-single-register">Read a single register</a></h1>
<p>Let's put all that theory into practice!</p>
<p>First things first we need to know the target addresses of both the accelerometer and the
magnetometer inside the chip, these can be found in the LSM303AGR's datasheet on page 39 and are:</p>
<ul>
<li>0011001 for the accelerometer</li>
<li>0011110 for the magnetometer</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> Remember that these are only the 7 leading bits of the address, the 8th bit is going to
be the bit that determines whether we are performing a read or write.</p>
</blockquote>
<p>Next up we'll need a register to read from. Lots of I2C chips out there will provide some sort of
device identification register for their controllers to read. Considering the thousands (or even
millions) of I2C chips out there it is highly likely that at some point two chips with the same
address will end up being built (after all the address is &quot;only&quot; 7 bit wide). With this device ID
register a driver can make sure that it is indeed talking to a LSM303AGR and not some other chip
that just happens to have the same address.  As you can read in the LSM303AGR's datasheet
(specifically on page 46 and 61) this part does provide two registers — <code>WHO_AM_I_A</code> at address
<code>0x0f</code> and <code>WHO_AM_I_M</code> at address <code>0x4f</code> — which contain some bit patterns that are unique to the
device. (The &quot;A&quot; is for &quot;Accelerometer&quot; and the &quot;M&quot; is for &quot;Magnetometer&quot;.)</p>
<p>The only thing missing now is the software part: we need to determin which API of the <code>microbit</code> or
a HAL crate we should use for this. If you read through the datasheet of the nRF chip you are using
you will soon find out that it doesn't actually have an I2C-specific peripheral.  Instead, it has
more general-purpose I2C-compatible peripherals called TWI (&quot;Two-Wire Interface&quot;), TWIM (&quot;Two-Wire
Interface Master&quot;) and TWIS (&quot;Two-Wire Interface Slave&quot;). We will normally be operating in
controller mode and will use the newer TWIM, which supports &quot;Easy DMA&quot; — the TWI is provided mostly
for backward compatibility with older devices.</p>
<p>Now if we put the documentation of the <a href="https://docs.rs/microbit-v2/0.11.0/microbit/hal/twim/index.html"><code>twi(m)</code> module</a> from the <code>microbit</code> crate
together with all the other information we have gathered so far we'll end up with this
piece of code to read out and print the two device IDs (<code>examples/chip-id.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m::asm::wfi;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use embedded_hal::i2c::I2c;
use microbit::{hal::twim, pac::twim0::frequency::FREQUENCY_A};

const ACCELEROMETER_ADDR: u8 = 0b0011001;
const MAGNETOMETER_ADDR: u8 = 0b0011110;

const ACCELEROMETER_ID_REG: u8 = 0x0f;
const MAGNETOMETER_ID_REG: u8 = 0x4f;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let mut i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut acc = [0u8];
    let mut mag = [0u8];

    // First write the address + register onto the bus, then read the chip's responses
    i2c.write_read(ACCELEROMETER_ADDR, &amp;[ACCELEROMETER_ID_REG], &amp;mut acc)
        .unwrap();
    i2c.write_read(MAGNETOMETER_ADDR, &amp;[MAGNETOMETER_ID_REG], &amp;mut mag)
        .unwrap();

    rprintln!(&quot;The accelerometer chip's id is: {:#b}&quot;, acc[0]);
    rprintln!(&quot;The magnetometer chip's id is: {:#b}&quot;, mag[0]);

    loop {
        wfi();
    }
}</code></pre></pre>
<p>Apart from the initialization, this piece of code should be straight forward if you understood the
I2C protocol as described before. The initialization here works similarly to the one from the UART
chapter.  We pass the peripheral as well as the pins that are used to communicate with the chip to
the constructor; and then the frequency we wish the bus to operate on, in this case 100 kHz (<code>K100</code>,
since identifiers can't start with a digit).</p>
<h2 id="testing-it-2"><a class="header" href="#testing-it-2">Testing it</a></h2>
<p>As usual</p>
<pre><code class="language-console">$ cargo embed --example chip-id
</code></pre>
<p>in order to test our little example program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-driver"><a class="header" href="#using-a-driver">Using a driver</a></h1>
<p>As we already discussed in chapter 5 <code>embedded-hal</code> provides abstractions
which can be used to write platform independent code that can interact with
hardware. In fact all the methods we have used to interact with hardware
in chapter 7 and up until now in chapter 8 were from traits, defined by <code>embedded-hal</code>.
Now we'll make actual use of the traits <code>embedded-hal</code> provides for the first time.</p>
<p>It would be pointless to implement a driver for our LSM303AGR for every platform
embedded Rust supports (and new ones that might eventually pop up). To avoid this a driver
can be written that consumes generic types that implement <code>embedded-hal</code> traits in order to provide
a platform agnostic version of a driver. Luckily for us this has already been done in the
<a href="https://crates.io/crates/lsm303agr"><code>lsm303agr</code></a> crate. Hence reading the actual accelerometer and magnetometer values will now
be basically a plug and play experience (plus reading a bit of documentation). In fact the <code>crates.io</code>
page already provides us with everything we need to know in order to read accelerometer data but using a Raspberry Pi. We'll
just have to adapt it to our chip:</p>
<p>Take a look at the linked page for the Raspberry Pi Linux sample code.</p>
<p>Because we already know how to create an instance of an object that implements the
<a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/blocking/i2c/index.html"><code>embedded_hal::blocking::i2c</code></a> traits from the <a href="11-i2c/read-a-single-register.html">previous page</a>, adapting
the sample code is straightforward (<code>examples/show-accel.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{AccelMode, AccelOutputDataRate, Lsm303agr};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };
    let mut timer0 = Timer::new(board.TIMER0);

    // Code from documentation
    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(
            &amp;mut timer0,
            AccelMode::HighResolution,
            AccelOutputDataRate::Hz50,
        )
        .unwrap();
    loop {
        if sensor.accel_status().unwrap().xyz_new_data() {
            let (x, y, z) = sensor.acceleration().unwrap().xyz_mg();
            // RTT instead of normal print
            rprintln!(&quot;Acceleration: x {} y {} z {}&quot;, x, y, z);
        }
    }
}</code></pre></pre>
<p>Just like the last snippet you should just be able to try this out like this:</p>
<pre><code class="language-console">$ cargo embed --example show-accel
</code></pre>
<p>Furthermore if you (physically) move around your micro:bit a little you should see the
acceleration numbers that are being printed change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-1"><a class="header" href="#the-challenge-1">The challenge</a></h1>
<p>The challenge for this chapter is, to build a small application that
communicates with the outside world via the serial interface introduced
in the last chapter. It should be able to receive the commands &quot;magnetometer&quot;
as well as &quot;accelerometer&quot; and then print the corresponding sensor data
in response. This time no template code will be provided since all you need
is already provided in the <a href="11-i2c/../10-uart/index.html">UART</a> and this chapter. However, here are a few clues:</p>
<ul>
<li>You might be interested in <code>core::str::from_utf8</code> to convert the bytes in the buffer to a <code>&amp;str</code>, since we need to compare with <code>&quot;magnetometer&quot;</code> and <code>&quot;accelerometer&quot;</code>.</li>
<li>You will (obviously) have to read the documentation of the magnetometer API, however
it's more or less equivalent to the accelerometer one</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-2"><a class="header" href="#my-solution-2">My solution</a></h1>
<p>My solution is in <code>src/main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::str;

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

use microbit::{
    hal::uarte::{self, Baudrate, Parity},
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use core::fmt::Write;
use heapless::Vec;
use lsm303agr::{AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate};

use serial_setup::UartePort;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let serial = uarte::Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );
    let mut serial = UartePort::new(serial);

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };
    let mut timer0 = Timer::new(board.TIMER0);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(
            &amp;mut timer0,
            AccelMode::HighResolution,
            AccelOutputDataRate::Hz50,
        )
        .unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz50,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();
    let mut buffer: Vec&lt;u8, 32&gt; = Vec::new();

    loop {
        buffer.clear();

        loop {
            let byte = serial.read().unwrap();

            if byte == b'\r' {
                break;
            }

            if buffer.push(byte).is_err() {
                write!(serial, &quot;error: buffer full\r\n&quot;).unwrap();
                break;
            }
        }

        if str::from_utf8(&amp;buffer).unwrap().trim() == &quot;accelerometer&quot; {
            while !sensor.accel_status().unwrap().xyz_new_data() {
                timer0.delay_ms(1u32);
            }

            let (x, y, z) = sensor.acceleration().unwrap().xyz_mg();
            write!(serial, &quot;Accelerometer: x {} y {} z {}\r\n&quot;, x, y, z).unwrap();
        } else if str::from_utf8(&amp;buffer).unwrap().trim() == &quot;magnetometer&quot; {
            while !sensor.mag_status().unwrap().xyz_new_data() {
                timer0.delay_ms(1u32);
            }

            let (x, y, z) = sensor.magnetic_field().unwrap().xyz_nt();
            write!(serial, &quot;Magnetometer: x {} y {} z {}\r\n&quot;, x, y, z).unwrap();
        } else {
            write!(serial, &quot;error: command not detected\r\n&quot;).unwrap();
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="led-compass"><a class="header" href="#led-compass">LED compass</a></h1>
<p>In this section, we'll implement a compass using the LEDs on the micro:bit. Like proper compasses,
our LED compass must point north somehow. It will do that by turning on one of its outer LEDs; the
LED turned on should point towards north.</p>
<p>Magnetic fields have both a magnitude, measured in Gauss or Teslas, and a <em>direction</em>. The
magnetometer on the micro:bit measures both the magnitude and the direction of an external magnetic
field, but it reports back the <em>decomposition</em> of said field along <em>its axes</em>.</p>
<p>The magnetometer has three axes associated with it. When the board is held flat with the LEDs facing
uupward and the logo facing forward, the X and Y axes span the plane that is the floor. The X axis
points to the left edge of the board. The Y axis points to the bottom (card connector) edge of the
board.  The Z axis points &quot;into the floor&quot;, so downwards: &quot;upside down&quot; since the chip is mounted on
the back. This is a &quot;right-handed&quot; coordinate system. It's all a bit confusing, since the reported
field strengths are components of the magnetic field vector.</p>
<p align="center">
<img title="MB2 Axes" src="12-led-compass/../assets/mb2-axes.jpg" width="500" />
</p>
<p>You should already be able to write a program that continuously prints the magnetometer data on the
RTT console from the <a href="12-led-compass/../11-i2c/index.html">I2C chapter</a>. After you write that program
(<code>examples/show-mag.rs</code>), locate where north is at your current location. Then line up your
micro:bit with that direction and observe how the sensor's X and Y measurements look.</p>
<p>Now rotate the board 90 degrees while keeping it parallel to the ground. What X, Y and Z values do
you see this time? Then rotate it 90 degrees again. What values do you see?</p>
<blockquote>
<p><strong>NOTE</strong> Of the two MB2s I have handy at the time of this writing, one of them seems to have a
somewhat broken magnetometer: the Z-axis is unusably offset. The manufacturer has a self-test
process for detecting this and a calibration process for mitigating this kind of &quot;hard iron&quot;
fault, which is usually the result of exposing the MB2 to a strong magnetic field at some
point. However, the <code>lsm303agr</code> crate currently doesn't support either of these, and it seems like
a lot for an introductory guide to embedded systems. If you have only one MB2 and it doesn't seem
to be working, you may just want to skip to the <a href="12-led-compass/../13-punch-o-meter/index.html">next chapter</a>. Cheap hardware: whatcha gonna do?</p>
</blockquote>
<p>The Earth's magnetic north is a fickle thing: it differs from true north in most places on Earth,
sometimes substantially. It can point down into the ground quite a bit. It changes over time.
Without allowing for all this, you won't get a very accurate compass even if your MB2 magnetometer
is perfect (it's not). This US NOAA calculator
<a href="https://www.ngdc.noaa.gov/geomag/calculators/mobileDeclination.shtml">https://www.ngdc.noaa.gov/geomag/calculators/mobileDeclination.shtml</a> can be visited on your mobile
device to get a good estimate of true north as well as magnetic north; you can give this UK BGS
<a href="http://www.geomag.bgs.ac.uk/data_service/models_compass/wmm_calc.html">calculator</a> your latitude, longitude and altitude to get both declination and inclination.  At my
location the &quot;declination&quot; (difference between true and magnetic north) is about 15°; the
&quot;inclination&quot; is an astonishing 67° down into the ground.</p>
<blockquote>
<p><strong>NOTE</strong> The LSM303AGR magnetometer is not a particularly accurate device out-of-the box. The
manufacturer recommends a fancy calibration procedure for finding adjustments to the magnetometer
readings. You can find further information, a sample calibration implementation and some fancier
compass graphics in <a href="12-led-compass/../appendix/3-mag-calibration/index.html">appendix 3</a>: since we're doing something fairly basic with the magnetometer
we won't worry about it in this chapter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magnitude"><a class="header" href="#magnitude">Magnitude</a></h1>
<p>How strong is the Earth's magnetic field?  According to the documentation about the
<a href="https://docs.rs/lsm303agr/1.1.0/lsm303agr/struct.Lsm303agr.html#method.magnetic_field"><code>magnetic_field()</code></a> method the <code>x</code> <code>y</code> <code>z</code> values we are getting are in nanoteslas. That means the
only thing we have to compute in order to get the magnitude of the magnetic field in nanoteslas is
the magnitude of the 3D vector that our <code>x</code> <code>y</code> <code>z</code> values describe. As you might remember from
school this is simply:</p>
<p>Rust does not have floating-point math functions such as <code>sqrtf()</code> in <code>core</code>, so our <code>no_std</code>
program has to get an implementation from somewhere. We use the <a href="https://crates.io/crates/libm">libm</a> crate for this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libm::sqrtf;
let magnitude = sqrtf(x * x + y * y + z * z);
<span class="boring">}</span></code></pre></pre>
<p>Putting all this together in a program (<code>examples/magnitude.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use libm::sqrtf;

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz10,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    loop {
        while !sensor.mag_status().unwrap().xyz_new_data() {
            timer0.delay_ms(1u32);
        }
        let (x, y, z) = sensor.magnetic_field().unwrap().xyz_nt();
        let (x, y, z) = (x as f32, y as f32, z as f32);
        let magnitude = sqrtf(x * x + y * y + z * z);
        rprintln!(&quot;{} mG&quot;, magnitude / 100.0);
    }
}</code></pre></pre>
<p>Run this with <code>cargo run --bin magnitude</code>.</p>
<p>This program will report the magnitude (strength) of the magnetic field in nanotesla (<code>nT</code>) and
milligauss (<code>mG</code>, where 1 <code>mG</code> = 100 <code>nT</code>). The magnitude of the Earth's magnetic field is in the
range of <code>250 mG</code> to <code>650 mG</code> (the magnitude varies depending on your geographical location) so you
ideally would see a value vaguely in that range. Your value will likely be off quite a bit because
the sensor has not been calibrated: see <a href="12-led-compass/../appendix/3-mag-calibration/index.html">appendix 3</a> for calibration. With calibration, I see a
magnitude of around <code>340 mG</code>.</p>
<p>Some questions:</p>
<ul>
<li>
<p>Without moving the board, what value do you see? Do you always see the same value?</p>
</li>
<li>
<p>If you rotate the board, does the magnitude change? Should it change?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-2"><a class="header" href="#the-challenge-2">The Challenge</a></h1>
<p>We'll use some fancy math to get the precise angle that the magnetic field forms with the X and Y
axes of the magnetometer. This will allow us to figure out which LED is pointing north.</p>
<p>We'll use the <code>atan2</code> function. This function returns an angle in the <code>-PI</code> to <code>PI</code> range. The
graphic below shows how this angle is measured:</p>
<p align="center">
<img class="white_bg" title="atan2" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Atan2_60.svg">
</p>
<p>Although not explicitly shown, in this graph the X axis points to the right and the Y axis points
up. Note that our coordinate system is rotated 180° from this.</p>
<p>Here's the starter code (in <code>templates/compass.rs</code>). <code>theta</code>, in radians, has already been
computed. You need to pick which LED to turn on based on the value of <code>theta</code>.</p>
<pre><code class="language-rs">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

// You'll find these useful ;-).
use core::f32::consts::PI;
use libm::{atan2f, floorf};

use microbit::{
    display::blocking::Display,
    hal::{Timer, twim},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor.set_mag_mode_and_odr(
        &amp;mut timer0,
        MagMode::HighResolution,
        MagOutputDataRate::Hz10,
    ).unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    let mut leds = [[0u8; 5]; 5];

    // Indexes of the 16 LEDs to be used in the display, and their
    // compass directions.
    #[rustfmt::skip]
    let indices = [
        (2, 0) /* W */, (3, 0) /* W-SW */, (3, 1) /* SW */, (4, 1) /* S-SW */,
        (4, 2) /* S */, (4, 3) /* S-SE */, (3, 3) /* SE */, (3, 4) /* E-SE */,
        (2, 4) /* E */, (1, 4) /* E-NE */, (1, 3) /* NE */, (0, 3) /* N-NE */,
        (0, 2) /* N */, (0, 1) /* N-NW */, (1, 1) /* NW */, (1, 0) /* W-NW */,
    ];

    loop {
        // Measure the magnetic field.
        let (x, y) = todo!();

        // Get an angle between -180° and 180° from the x axis.
        let theta = atan2f(y as f32, x as f32);

        // Figure out what LED index to blink.
        let index = todo!();

        // Blink the given LED.
        let (r, c) = indices[index];
        leds[r][c] = 255u8;
        display.show(&amp;mut timer0, leds, 50);
        leds[r][c] = 0u8;
        display.show(&amp;mut timer0, leds, 50);
    }
}
</code></pre>
<p>Suggestions/tips:</p>
<ul>
<li>A whole circle rotation equals 360 degrees.</li>
<li><code>PI</code> radians is equivalent to 180 degrees.</li>
<li>If <code>theta</code> is zero, which direction are you pointing at?</li>
<li>If <code>theta</code> is instead very close to zero, which direction are you pointing at?</li>
<li>If <code>theta</code> keeps increasing, at what value should you change the direction</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-3"><a class="header" href="#my-solution-3">My Solution</a></h1>
<p>Here's my solution (in <code>src/main.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

// You'll find these useful ;-).
use core::f32::consts::PI;
use libm::{atan2f, floorf};

use microbit::{
    display::blocking::Display,
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{Lsm303agr, MagMode, MagOutputDataRate};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut timer0 = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_mag_mode_and_odr(
            &amp;mut timer0,
            MagMode::HighResolution,
            MagOutputDataRate::Hz10,
        )
        .unwrap();
    let mut sensor = sensor.into_mag_continuous().ok().unwrap();

    let mut leds = [[0u8; 5]; 5];

    // Indexes of the 16 LEDs to be used in the display, and their
    // compass directions.
    #[rustfmt::skip]
    let indices = [
        (2, 0), /* W */
        (3, 0), /* W-SW */
        (3, 1), /* SW */
        (4, 1), /* S-SW */
        (4, 2), /* S */
        (4, 3), /* S-SE */
        (3, 3), /* SE */
        (3, 4), /* E-SE */
        (2, 4), /* E */
        (1, 4), /* E-NE */
        (1, 3), /* NE */
        (0, 3), /* N-NE */
        (0, 2), /* N */
        (0, 1), /* N-NW */
        (1, 1), /* NW */
        (1, 0), /* W-NW */
    ];

    loop {
        while !sensor.mag_status().unwrap().xyz_new_data() {
            timer0.delay_ms(1u32);
        }
        let (x, y, _) = sensor.magnetic_field().unwrap().xyz_nt();

        // Get an angle between -180° and 180° from the x axis.
        let theta = atan2f(y as f32, x as f32);

        // Cut the unit circle into thirty-two segments,
        // with pairs of adjacent segments corresponding to
        // each compass direction.
        let seg = floorf(16.0 * theta / PI) as i8;

        // Figure out what LED index to blink.
        let index = if seg &gt;= 15 || seg &lt;= -15 {
            8
        } else if seg &gt;= 0 {
            (seg / 2) as usize
        } else {
            ((31 + seg) / 2) as usize
        };

        // Blink the given LED.
        let (r, c) = indices[index];
        leds[r][c] = 255u8;
        display.show(&amp;mut timer0, leds, 50);
        leds[r][c] = 0u8;
        display.show(&amp;mut timer0, leds, 50);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punch-o-meter"><a class="header" href="#punch-o-meter">Punch-o-meter</a></h1>
<p>In this section we'll be playing with the accelerometer that's in the board.</p>
<p>What are we building this time? A punch-o-meter! We'll be measuring the power of your jabs. Well,
actually the maximum acceleration that you can reach because acceleration is what accelerometers
measure. Strength and acceleration are proportional though so it's a good approximation.</p>
<p>As we already know from previous chapters the accelerometer is built inside the LSM303AGR package.
And just like the magnetometer, it is accessible using the
I2C bus. </p>
<p>The accelerometer also has the same coordinate system as the magnetometer. Here's a reminder:</p>
<p align="center">
<img title="MB2 Axes" src="13-punch-o-meter/../assets/mb2-axes.jpg" width="500" />
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gravity-is-up"><a class="header" href="#gravity-is-up">Gravity is up?</a></h1>
<p>What's the first thing we'll do?</p>
<p>Perform a sanity check!</p>
<p>You should already be able to write a program that continuously prints the accelerometer data on the
RTT console from the <a href="13-punch-o-meter/../11-i2c/index.html">I2C chapter</a>. Mine is in <code>examples/show-accel.rs</code>. Do you
observe something interesting even when holding the board parallel to the floor with the back side
facing up?  (Remember that the accelerometer is mounted on the back of the board, so holding it
upside-down like this makes the Z axis point up.)</p>
<p>What you should see when holding the board like this is that both the X and Y values are rather
close to 0, while the Z value is at around 1000. Which is weird: the board is not moving, yet its
acceleration is non-zero. What's going on? This must be related to the gravity, right? Because the
acceleration of gravity is <code>1 g</code> (aha, <code>1 g</code> = -1000 from the accelerometer). But the gravity pulls
objects downwards so the acceleration along the Z axis should be positive, not negative.</p>
<p>Did the program get the Z axis backwards? Nope, you can test rotating the board to align the gravity
to the X or Y axis but the acceleration measured by the accelerometer is always pointing up.</p>
<p>What happens here is that the accelerometer is measuring the <em>proper acceleration</em> of the board, not
the acceleration <em>you</em> are observing. This proper acceleration is the acceleration of the board as
seen from an observer that's in free fall. An observer that's in free fall is moving toward the
center of the Earth with an acceleration of <code>1g</code>; from its point of view the board is actually
moving upwards (away from the center of the Earth) with an acceleration of <code>1g</code>. And that's why the
proper acceleration is pointing up. This also means that if the board was in free fall, the
accelerometer would report a proper acceleration of zero. Please, don't try that at home. Or do, if
you're willing to risk your MB2 by dropping it.</p>
<p>Yes, physics is hard. Let's move on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-3"><a class="header" href="#the-challenge-3">The challenge</a></h1>
<p>To keep things simple, we'll measure the acceleration only in the X axis while the board remains
horizontal. That way we won't have to deal with subtracting that <em>fictitious</em> <code>1g</code> we observed
before which would be hard because that <code>1g</code> could have X Y Z components depending on how the board
is oriented.</p>
<p>Here's what the punch-o-meter must do:</p>
<ul>
<li>By default, the app is not &quot;observing&quot; the acceleration of the board.</li>
<li>When a significant X acceleration is detected (i.e. the acceleration goes above some threshold),
the app should start a new measurement.</li>
<li>During that measurement interval, the app should keep track of the maximum acceleration observed</li>
<li>After the measurement interval ends, the app must report the maximum acceleration observed. You
can report the value using the <code>rprintln!</code> macro.</li>
</ul>
<p>Give it a try and let me know how hard you can punch <code>;-)</code>.</p>
<blockquote>
<p><strong>NOTE</strong> There is an additional API that should be useful for this task that we haven't
discussed yet: the <a href="https://docs.rs/lsm303agr/1.1.0/lsm303agr/struct.Lsm303agr.html#method.set_accel_scale"><code>set_accel_scale</code></a> one which you need to measure high g values.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-solution-4"><a class="header" href="#my-solution-4">My solution</a></h1>
<p>Here's my solution (<code>src/main.rs</code>). Note that you can get quite high G values by rapping the edge of
your MB2 on a table. Note also that this can break the accelerometer, so probably don't?</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

const TICKS_PER_SEC: u32 = 400;
const THRESHOLD: f32 = 1.5;

use cortex_m::asm::nop;
use cortex_m_rt::entry;
use panic_rtt_target as _;
use rtt_target::{rprintln, rtt_init_print};

use microbit::{
    hal::{twim, Timer},
    pac::twim0::frequency::FREQUENCY_A,
};

use lsm303agr::{AccelMode, AccelOutputDataRate, AccelScale, Lsm303agr};

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = microbit::Board::take().unwrap();

    let i2c = { twim::Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100) };

    let mut delay = Timer::new(board.TIMER0);
    let mut sensor = Lsm303agr::new_with_i2c(i2c);
    sensor.init().unwrap();
    sensor
        .set_accel_mode_and_odr(&amp;mut delay, AccelMode::Normal, AccelOutputDataRate::Hz400)
        .unwrap();
    // Allow the sensor to measure up to 16 G since human punches
    // can actually be quite fast
    sensor.set_accel_scale(AccelScale::G16).unwrap();

    let mut max_g = 0.;
    let mut countdown_ticks = None;

    loop {
        while !sensor.accel_status().unwrap().xyz_new_data() {
            nop();
        }
        // x acceleration in g
        let (x, _, _) = sensor.acceleration().unwrap().xyz_mg();
        let g_x = x as f32 / 1000.0;

        if let Some(ticks) = countdown_ticks {
            if ticks &gt; 0 {
                // countdown isn't done yet
                if g_x &gt; max_g {
                    max_g = g_x;
                }
                countdown_ticks = Some(ticks - 1);
            } else {
                // Countdown is done: report max value
                rprintln!(&quot;Max acceleration: {}g&quot;, max_g);

                // Reset
                max_g = 0.;
                countdown_ticks = None;
            }
        } else {
            // If acceleration goes above a threshold, we start measuring
            if g_x &gt; THRESHOLD {
                rprintln!(&quot;START!&quot;);

                max_g = g_x;
                countdown_ticks = Some(TICKS_PER_SEC);
            }
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snake-game"><a class="header" href="#snake-game">Snake game</a></h1>
<p>We're now going to implement a basic <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">snake</a>
game that you can play on an MB2 using its 5×5 LED matrix as a display and its two buttons as
controls. In doing so, we will build on some of the concepts covered in the earlier chapters of this
book, and also learn about some new peripherals and concepts.</p>
<p>In particular, we will be using the concept of hardware interrupts to allow our program to interact
with multiple peripherals at once. Interrupts are a common way to implement concurrency in embedded
contexts. There is a good introduction to concurrency in an embedded context <a href="https://docs.rust-embedded.org/book/concurrency/index.html">here</a> that
you might read through before proceeding.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>The source code here is more modular than it probably should be. This fine-grained modularity allows
us to look at the source code a little at a time. We will build the code bottom-up: we will first
build three modules — <code>game</code>, <code>controls</code> and <code>display</code>, and then compose these to build the final
program. Each module will have a top-level source file and one or more included source files: for
example, the <code>game</code> module will consist of <code>src/game.rs</code>, <code>src/game/coords.rs</code>,
<code>src/game/movement.rs</code>, etc. The Rust <code>mod</code> statement is used to combine the various components of
the module. <em>The Rust Programming Language</em> has a good <a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">description</a> of Rust's module system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-logic"><a class="header" href="#game-logic">Game logic</a></h1>
<p>The first module we will build is the game logic. You are probably familiar with <a href="https://en.wikipedia.org/wiki/Snake_%28video_game_genre%29">snake</a> games, but
if not, the basic idea is that the player guides a snake around a 2D grid. At any given time, there
is some &quot;food&quot; at a random location on the grid and the goal of the game is to get the snake to
&quot;eat&quot; as much food as possible. Each time the snake eats food it grows in length. The player loses
if the snake crashes into its own tail.</p>
<p>In some variants of the game, the player also loses if the snake crashes into the edge of the grid,
but given the small size of our grid we are going to implement a &quot;wraparound&quot; rule: if the snake
goes off one edge of the grid, it will continue from the opposite edge.</p>
<h2 id="the-game-module"><a class="header" href="#the-game-module">The <code>game</code> module</a></h2>
<p>We will build up the game mechanics in the <code>game</code> module.</p>
<h3 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h3>
<p>We start by defining a coordinate system for our game (<code>src/game/coords.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Prng;

use heapless::FnvIndexSet;

/// A single point on the grid.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct Coords {
    // Signed ints to allow negative values (handy when checking if we have gone
    // off the top or left of the grid)
    pub row: i8,
    pub col: i8,
}

impl Coords {
    /// Get random coordinates within a grid. `exclude` is an optional set of
    /// coordinates which should be excluded from the output.
    pub fn random(rng: &amp;mut Prng, exclude: Option&lt;&amp;FnvIndexSet&lt;Coords, 32&gt;&gt;) -&gt; Self {
        let mut coords = Coords {
            row: ((rng.random_u32() as usize) % 5) as i8,
            col: ((rng.random_u32() as usize) % 5) as i8,
        };
        while exclude.is_some_and(|exc| exc.contains(&amp;coords)) {
            coords = Coords {
                row: ((rng.random_u32() as usize) % 5) as i8,
                col: ((rng.random_u32() as usize) % 5) as i8,
            }
        }
        coords
    }

    /// Whether the point is outside the bounds of the grid.
    pub fn is_out_of_bounds(&amp;self) -&gt; bool {
        self.row &lt; 0 || self.row &gt;= 5 || self.col &lt; 0 || self.col &gt;= 5
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We use a <code>Coords</code> struct to refer to a position on the grid. Because <code>Coords</code> only contains two
integers, we tell the compiler to derive an implementation of the <code>Copy</code> trait for it, so we can
pass around <code>Coords</code> structs without having to worry about ownership.</p>
<h3 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h3>
<p>We define an associated function, <code>Coords::random</code>, which will give us a random position on the
grid. We will use this later to determine where to place the snake's food.</p>
<p>To generate random coordinates, we need a source of random numbers. The nRF52833 has a hardware
random number generator (HWRNG) peripheral, documented at section 6.19 of the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf">nRF52833 spec</a>. The
HAL gives us a simple interface to the HWRNG via the <code>microbit::hal::rng::Rng</code> struct. The HWRNG may
not be fast enough for a game; it is also convenient for testing to be able to replicate the
sequence of random numbers produced by the generator between runs, which is impossible for the HWRNG
by design. We thus also define a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random</a> number generator (PRNG). The PRNG uses an
<a href="https://en.wikipedia.org/wiki/Xorshift">xorshift</a> algorithm to generate pseudo-random <code>u32</code> values. The algorithm is basic and not
cryptographically secure, but it is efficient, easy to implement and good enough for our humble
snake game. Our <code>Prng</code> struct requires an initial seed value, which we do get from the RNG
peripheral.</p>
<p>All of this makes up <code>src/game/rng.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::Rng;

/// A basic pseudo-random number generator.
pub struct Prng {
    value: u32,
}

impl Prng {
    pub fn seeded(rng: &amp;mut Rng) -&gt; Self {
        Self::new(rng.random_u32())
    }

    pub fn new(seed: u32) -&gt; Self {
        Self { value: seed }
    }

    /// Basic xorshift PRNG function: see &lt;https://en.wikipedia.org/wiki/Xorshift&gt;
    fn xorshift32(mut input: u32) -&gt; u32 {
        input ^= input &lt;&lt; 13;
        input ^= input &gt;&gt; 17;
        input ^= input &lt;&lt; 5;
        input
    }

    /// Return a pseudo-random u32.
    pub fn random_u32(&amp;mut self) -&gt; u32 {
        self.value = Self::xorshift32(self.value);
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="movement"><a class="header" href="#movement">Movement</a></h3>
<p>We also need to define a few <code>enum</code>s that help us manage the game's state: direction of movement,
direction to turn, the current game status and the outcome of a particular &quot;step&quot; in the game (ie, a
single movement of the snake). <code>src/game/movement.rs</code> contains these.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::Coords;

/// Define the directions the snake can move.
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
}

/// What direction the snake should turn.
#[derive(Debug, Copy, Clone)]
pub enum Turn {
    Left,
    Right,
    None,
}

/// The current status of the game.
pub enum GameStatus {
    Won,
    Lost,
    Ongoing,
}

/// The outcome of a single move/step.
pub enum StepOutcome {
    /// Grid full (player wins)
    Full,
    /// Snake has collided with itself (player loses)
    Collision,
    /// Snake has eaten some food
    Eat(Coords),
    /// Snake has moved (and nothing else has happened)
    Move(Coords),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="a-snake-a-snaaake"><a class="header" href="#a-snake-a-snaaake">A Snake (<em>A Snaaake!</em>)</a></h3>
<p>Next up we define a <code>Snake</code> struct, which keeps track of the coordinates occupied by the snake and
its direction of travel. We use a queue (<code>heapless::spsc::Queue</code>) to keep track of the order of
coordinates and a hash set (<code>heapless::FnvIndexSet</code>) to allow for quick collision detection.  The
<code>Snake</code> has methods to allow it to move. <code>src/game/snake.rs</code> gets this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Coords, Direction, FnvIndexSet, Turn};

use heapless::spsc::Queue;

pub struct Snake {
    /// Coordinates of the snake's head.
    pub head: Coords,
    /// Queue of coordinates of the rest of the snake's body. The end of the tail is
    /// at the front.
    pub tail: Queue&lt;Coords, 32&gt;,
    /// A set containing all coordinates currently occupied by the snake (for fast
    /// collision checking).
    pub coord_set: FnvIndexSet&lt;Coords, 32&gt;,
    /// The direction the snake is currently moving in.
    pub direction: Direction,
}

impl Snake {
    pub fn make_snake() -&gt; Self {
        let head = Coords { row: 2, col: 2 };
        let initial_tail = Coords { row: 2, col: 1 };
        let mut tail = Queue::new();
        tail.enqueue(initial_tail).unwrap();
        let mut coord_set: FnvIndexSet&lt;Coords, 32&gt; = FnvIndexSet::new();
        coord_set.insert(head).unwrap();
        coord_set.insert(initial_tail).unwrap();
        Self {
            head,
            tail,
            coord_set,
            direction: Direction::Right,
        }
    }

    /// Move the snake onto the tile at the given coordinates. If `extend` is false,
    /// the snake's tail vacates the rearmost tile.
    pub fn move_snake(&amp;mut self, coords: Coords, extend: bool) {
        // Location of head becomes front of tail
        self.tail.enqueue(self.head).unwrap();
        // Head moves to new coords
        self.head = coords;
        self.coord_set.insert(coords).unwrap();
        if !extend {
            let back = self.tail.dequeue().unwrap();
            self.coord_set.remove(&amp;back);
        }
    }

    fn turn_right(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Right,
            Direction::Down =&gt; Direction::Left,
            Direction::Left =&gt; Direction::Up,
            Direction::Right =&gt; Direction::Down,
        }
    }

    fn turn_left(&amp;mut self) {
        self.direction = match self.direction {
            Direction::Up =&gt; Direction::Left,
            Direction::Down =&gt; Direction::Right,
            Direction::Left =&gt; Direction::Down,
            Direction::Right =&gt; Direction::Up,
        }
    }

    pub fn turn(&amp;mut self, direction: Turn) {
        match direction {
            Turn::Left =&gt; self.turn_left(),
            Turn::Right =&gt; self.turn_right(),
            Turn::None =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="game-module-top-level"><a class="header" href="#game-module-top-level">Game Module Top-Level</a></h3>
<p>The <code>Game</code> struct keeps track of the game state. It holds a <code>Snake</code> object, the current coordinates
of the food, the speed of the game (which is used to determine the time that elapses between each
movement of the snake), the status of the game (whether the game is ongoing or the player has won or
lost) and the player's score.</p>
<p>This struct contains methods to handle each step of the game, determining the snake's next move and
updating the game state accordingly. It also contains two methods--<code>game_matrix</code> and
<code>score_matrix</code>--that output 2D arrays of values which can be used to display the game state or the
player score on the LED matrix (as we will see later).</p>
<p>We put the <code>Game</code> struct at the top of the <code>game</code> module, in <code>src/game.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod coords;
mod movement;
mod rng;
mod snake;

use crate::Rng;

pub use coords::Coords;
pub use movement::{Direction, GameStatus, StepOutcome, Turn};
pub use rng::Prng;
pub use snake::Snake;

use heapless::FnvIndexSet;

/// Struct to hold game state and associated behaviour
pub struct Game {
    pub status: GameStatus,
    rng: Prng,
    snake: Snake,
    food_coords: Coords,
    speed: u8,
    score: u8,
}

impl Game {
    pub fn new(rng: &amp;mut Rng) -&gt; Self {
        let mut rng = Prng::seeded(rng);
        let mut tail: FnvIndexSet&lt;Coords, 32&gt; = FnvIndexSet::new();
        tail.insert(Coords { row: 2, col: 1 }).unwrap();
        let snake = Snake::make_snake();
        let food_coords = Coords::random(&amp;mut rng, Some(&amp;snake.coord_set));
        Self {
            rng,
            snake,
            food_coords,
            speed: 1,
            status: GameStatus::Ongoing,
            score: 0,
        }
    }

    /// Reset the game state to start a new game.
    pub fn reset(&amp;mut self) {
        self.snake = Snake::make_snake();
        self.place_food();
        self.speed = 1;
        self.status = GameStatus::Ongoing;
        self.score = 0;
    }

    /// Randomly place food on the grid.
    fn place_food(&amp;mut self) -&gt; Coords {
        let coords = Coords::random(&amp;mut self.rng, Some(&amp;self.snake.coord_set));
        self.food_coords = coords;
        coords
    }

    /// &quot;Wrap around&quot; out of bounds coordinates (eg, coordinates that are off to the
    /// left of the grid will appear in the rightmost column). Assumes that
    /// coordinates are out of bounds in one dimension only.
    fn wraparound(&amp;self, coords: Coords) -&gt; Coords {
        if coords.row &lt; 0 {
            Coords { row: 4, ..coords }
        } else if coords.row &gt;= 5 {
            Coords { row: 0, ..coords }
        } else if coords.col &lt; 0 {
            Coords { col: 4, ..coords }
        } else {
            Coords { col: 0, ..coords }
        }
    }

    /// Determine the next tile that the snake will move on to (without actually
    /// moving the snake).
    fn get_next_move(&amp;self) -&gt; Coords {
        let head = &amp;self.snake.head;
        let next_move = match self.snake.direction {
            Direction::Up =&gt; Coords {
                row: head.row - 1,
                col: head.col,
            },
            Direction::Down =&gt; Coords {
                row: head.row + 1,
                col: head.col,
            },
            Direction::Left =&gt; Coords {
                row: head.row,
                col: head.col - 1,
            },
            Direction::Right =&gt; Coords {
                row: head.row,
                col: head.col + 1,
            },
        };
        if next_move.is_out_of_bounds() {
            self.wraparound(next_move)
        } else {
            next_move
        }
    }

    /// Assess the snake's next move and return the outcome. Doesn't actually update
    /// the game state.
    fn get_step_outcome(&amp;self) -&gt; StepOutcome {
        let next_move = self.get_next_move();
        if self.snake.coord_set.contains(&amp;next_move) {
            // We haven't moved the snake yet, so if the next move is at the end of
            // the tail, there won't actually be any collision (as the tail will have
            // moved by the time the head moves onto the tile)
            if next_move != *self.snake.tail.peek().unwrap() {
                StepOutcome::Collision
            } else {
                StepOutcome::Move(next_move)
            }
        } else if next_move == self.food_coords {
            if self.snake.tail.len() == 23 {
                StepOutcome::Full
            } else {
                StepOutcome::Eat(next_move)
            }
        } else {
            StepOutcome::Move(next_move)
        }
    }

    /// Handle the outcome of a step, updating the game's internal state.
    fn handle_step_outcome(&amp;mut self, outcome: StepOutcome) {
        self.status = match outcome {
            StepOutcome::Collision =&gt; GameStatus::Lost,
            StepOutcome::Full =&gt; GameStatus::Won,
            StepOutcome::Eat(c) =&gt; {
                self.snake.move_snake(c, true);
                self.place_food();
                self.score += 1;
                if self.score % 5 == 0 {
                    self.speed += 1
                }
                GameStatus::Ongoing
            }
            StepOutcome::Move(c) =&gt; {
                self.snake.move_snake(c, false);
                GameStatus::Ongoing
            }
        }
    }

    pub fn step(&amp;mut self, turn: Turn) {
        self.snake.turn(turn);
        let outcome = self.get_step_outcome();
        self.handle_step_outcome(outcome);
    }

    /// Calculate the length of time to wait between game steps, in milliseconds.
    /// Generally this will get lower as the player's score increases, but need to
    /// be careful it cannot result in a value below zero.
    pub fn step_len_ms(&amp;self) -&gt; u32 {
        let result = 1000 - (200 * ((self.speed as i32) - 1));
        if result &lt; 200 {
            200u32
        } else {
            result as u32
        }
    }

    /// Return an array representing the game state, which can be used to display the
    /// state on the microbit's LED matrix. Each `_brightness` parameter should be a
    /// value between 0 and 9.
    pub fn game_matrix(
        &amp;self,
        head_brightness: u8,
        tail_brightness: u8,
        food_brightness: u8,
    ) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        values[self.snake.head.row as usize][self.snake.head.col as usize] = head_brightness;
        for t in &amp;self.snake.tail {
            values[t.row as usize][t.col as usize] = tail_brightness
        }
        values[self.food_coords.row as usize][self.food_coords.col as usize] = food_brightness;
        values
    }

    /// Return an array representing the game score, which can be used to display the
    /// score on the microbit's LED matrix (by illuminating the equivalent number of
    /// LEDs, going left-&gt;right and top-&gt;bottom).
    pub fn score_matrix(&amp;self) -&gt; [[u8; 5]; 5] {
        let mut values = [[0u8; 5]; 5];
        let full_rows = (self.score as usize) / 5;
        #[allow(clippy::needless_range_loop)]
        for r in 0..full_rows {
            values[r] = [1; 5];
        }
        for c in 0..(self.score as usize) % 5 {
            values[full_rows][c] = 1;
        }
        values
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next we will add the ability to control the snake's movements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controls"><a class="header" href="#controls">Controls</a></h1>
<p>Our protagonist will be controlled by the two buttons on the front of the micro:bit. Button A will
turn to the snake's left, and button B will turn to the snake's right.</p>
<p>We will use the <code>microbit::pac::interrupt</code> macro to handle button presses in a concurrent way. The
interrupt will be generated by the MB2's General Purpose Input/Output Tasks and Events (GPIOTE)
peripheral.</p>
<h2 id="the-controls-module"><a class="header" href="#the-controls-module">The <code>controls</code> module</a></h2>
<p>We will need to keep track of two separate pieces of global mutable state: A reference to the
<code>GPIOTE</code> peripheral, and a record of the selected direction to turn next.</p>
<p>Shared data is wrapped in a <code>RefCell</code> to permit interior mutability and locking. You can learn more
about <code>RefCell</code> by reading the <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell documentation</a> and the <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability chapter</a> of the
Rust Book].  The <code>RefCell</code> is, in turn, wrapped in a <code>cortex_m::interrupt::Mutex</code> to allow safe
access.  The Mutex provided by the <code>cortex_m</code> crate uses the concept of a <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>.  Data
in a Mutex can only be accessed from within a function or closure passed to
<code>cortex_m::interrupt:free</code> (renamed here to <code>interrupt_free</code> for clarity), which ensures that the
code in the function or closure cannot itself be interrupted.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>First, we will initialise the buttons (<code>src/controls/init.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Buttons, GPIO};

use cortex_m::interrupt::free as interrupt_free;
use microbit::{
    hal::{
        gpio::{Floating, Input, Pin},
        gpiote::{Gpiote, GpioteChannel},
    },
    pac,
};

/// Initialise the buttons and enable interrupts.
pub fn init_buttons(board_gpiote: pac::GPIOTE, board_buttons: Buttons) {
    let gpiote = Gpiote::new(board_gpiote);

    fn init_channel(channel: &amp;GpioteChannel&lt;'_&gt;, button: &amp;Pin&lt;Input&lt;Floating&gt;&gt;) {
        channel.input_pin(button).hi_to_lo().enable_interrupt();
        channel.reset_events();
    }

    let channel0 = gpiote.channel0();
    init_channel(&amp;channel0, &amp;board_buttons.button_a.degrade());

    let channel1 = gpiote.channel1();
    init_channel(&amp;channel1, &amp;board_buttons.button_b.degrade());

    interrupt_free(move |cs| {
        *GPIO.borrow(cs).borrow_mut() = Some(gpiote);

        unsafe {
            pac::NVIC::unmask(pac::Interrupt::GPIOTE);
        }
        pac::NVIC::unpend(pac::Interrupt::GPIOTE);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>GPIOTE</code> peripheral on the nRF52 has 8 &quot;channels&quot;, each of which can be connected to a <code>GPIO</code>
pin and configured to respond to certain events, including rising edge (transition from low to high
signal) and falling edge (high to low signal). A button is a <code>GPIO</code> pin which has high signal when
not pressed and low signal otherwise. Therefore, a button press is a falling edge.</p>
<p>Note the awkward use of the function <code>init_channel()</code> in initialization to avoid copy-pasting the
button initialization code. The types that the various embedded crates for the MB2 have been hiding
from you are sometimes a bit scary. I would encourage you to explore the type structure of the HAL
and PAC crates at some point, as it is a bit odd and takes getting used to. In particular, note that
each pin on the microbit has <em>its own unique type.</em> The purpose of the <code>degrade()</code> function in
initialization is to convert these to a common type that can reasonably be used as an argument to
<code>init_channel()</code> and thence to <code>input_pin()</code>.</p>
<p>We connect <code>channel0</code> to <code>button_a</code> and <code>channel1</code> to <code>button_b</code>. In each case, we set the button up
to generate events on a falling edge (<code>hi_to_lo</code>). We store a reference to our <code>GPIOTE</code> peripheral
in the <code>GPIO</code> Mutex. We then <code>unmask</code> <code>GPIOTE</code> interrupts, allowing them to be propagated by the
hardware, and call <code>unpend</code> to clear any interrupts with pending status (which may have been
generated prior to the interrupts being unmasked).</p>
<h3 id="interrupt-handler"><a class="header" href="#interrupt-handler">Interrupt handler</a></h3>
<p>Next, we write the code that handles the interrupt. We use the <code>interrupt</code> macro re-exported from
the <code>nrf52833_hal</code> crate. We define a function with the same name as the interrupt we want to handle
(you can see them all
<a href="https://docs.rs/nrf52833-hal/latest/nrf52833_hal/pac/enum.Interrupt.html">here</a>) and annotate it
with <code>#[interrupt]</code> (<code>src/controls/interrupt.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::{Turn, GPIO, TURN};

use cortex_m::interrupt::free as interrupt_free;
use microbit::pac::{self, interrupt};

#[pac::interrupt]
fn GPIOTE() {
    interrupt_free(|cs| {
        if let Some(gpiote) = GPIO.borrow(cs).borrow().as_ref() {
            let a_pressed = gpiote.channel0().is_event_triggered();
            let b_pressed = gpiote.channel1().is_event_triggered();

            let turn = match (a_pressed, b_pressed) {
                (true, false) =&gt; Turn::Left,
                (false, true) =&gt; Turn::Right,
                _ =&gt; Turn::None,
            };

            gpiote.channel0().reset_events();
            gpiote.channel1().reset_events();

            *TURN.borrow(cs).borrow_mut() = turn;
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<p>When a <code>GPIOTE</code> interrupt is generated, we check each button to see whether it has been pressed. If
only button A has been pressed, we record that the snake should turn to the left. If only button B
has been pressed, we record that the snake should turn to the right. In any other case, we record
that the snake should not make any turn. (Having both buttons pressed &quot;at the same time&quot; is
exceedingly unlikely: button presses are noted almost instantly, and this interrupt handler runs
very fast — it would be hard to get both buttons down in time for this to happen. Similarly, it
would be hard to press a button for a short enough time for this code to miss it and report that
neither button is pressed. Still, Rust enforces that you plan for these unexpected cases: the code
will not compile unless you check all the possibilities.) The relevant turn is stored in the <code>TURN</code>
Mutex. All of this happens within an <code>interrupt_free</code> block, to ensure that we cannot be interrupted
by some other event while handling this interrupt.</p>
<p>Finally, we expose a simple function to get the next turn (<code>src/controls.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod init;
mod interrupt;

pub use init::init_buttons;

use crate::game::Turn;
use core::cell::RefCell;
use cortex_m::interrupt::{free as interrupt_free, Mutex};
use microbit::{board::Buttons, hal::gpiote::Gpiote};
pub static GPIO: Mutex&lt;RefCell&lt;Option&lt;Gpiote&gt;&gt;&gt; = Mutex::new(RefCell::new(None));
pub static TURN: Mutex&lt;RefCell&lt;Turn&gt;&gt; = Mutex::new(RefCell::new(Turn::None));

/// Get the next turn (ie, the turn corresponding to the most recently pressed button).
pub fn get_turn(reset: bool) -&gt; Turn {
    interrupt_free(|cs| {
        let turn = *TURN.borrow(cs).borrow();
        if reset {
            *TURN.borrow(cs).borrow_mut() = Turn::None
        }
        turn
    })
}
<span class="boring">}</span></code></pre></pre>
<p>This function simply returns the current value of the <code>TURN</code> Mutex. It takes a single boolean
argument, <code>reset</code>. If <code>reset</code> is <code>true</code>, the value of <code>TURN</code> is reset, i.e., set to <code>Turn::None</code>.</p>
<p>Next we will build support for a high-fidelity game display.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-non-blocking-display"><a class="header" href="#using-the-non-blocking-display">Using the non-blocking display</a></h1>
<p>We will next display the snake and food on the LEDs of the MB2 screen. So far, we have used the
blocking interface, which provides for LEDs to be either maximally bright or turned off. With this,
a basic functioning snake game would be possible. But you might find that when the snake got a bit
longer, it would be difficult to tell the snake from the food, and to tell which direction the snake
was heading. Let's figure out how to allow the LED brightness to vary: we can make the snake's body
a bit dimmer, which will help sort out the clutter.</p>
<p>The <code>microbit</code> library makes available two different interfaces to the LED matrix. There is the
blocking interface we've already seen in previous chapters. There is also a non-blocking interface
which allows you to customise the brightness of each LED. At the hardware level, each LED is either
&quot;on&quot; or &quot;off&quot;, but the <code>microbit::display::nonblocking</code> module simulates ten levels of brightness
for each LED by rapidly switching the LED on and off.</p>
<p>(There is no great reason the two display modes of the <code>microbit</code> library crate have to be separate
and use separate code. A more complete design would allow either non-blocking or blocking use of a
single display API with variable brightness levels and refresh rates specified by the user. Never
assume that the stuff you have been handed is perfected, or even close. Always think about what you
might do differently. For now, though, we'll work with what we have, which is adequate for our
immediate purpose.)</p>
<p>The code to interact with the non-blocking interface (<code>src/display.rs</code>) is pretty simple and will
follow a similar structure to the code we used to interact with the buttons. This time we'll start
at the top level.</p>
<h2 id="display-module"><a class="header" href="#display-module">Display module</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod interrupt;
pub mod show;

pub use show::{clear_display, display_image};

use core::cell::RefCell;
use cortex_m::interrupt::{free as interrupt_free, Mutex};
use microbit::display::nonblocking::Display;
use microbit::gpio::DisplayPins;
use microbit::pac;
use microbit::pac::TIMER1;

static DISPLAY: Mutex&lt;RefCell&lt;Option&lt;Display&lt;TIMER1&gt;&gt;&gt;&gt; = Mutex::new(RefCell::new(None));

pub fn init_display(board_timer: TIMER1, board_display: DisplayPins) {
    let display = Display::new(board_timer, board_display);

    interrupt_free(move |cs| {
        *DISPLAY.borrow(cs).borrow_mut() = Some(display);
    });
    unsafe { pac::NVIC::unmask(pac::Interrupt::TIMER1) }
}
<span class="boring">}</span></code></pre></pre>
<p>First, we initialise a <code>microbit::display::nonblocking::Display</code> struct representing the LED
display, passing it the board's <code>TIMER1</code> and <code>DisplayPins</code> peripherals. Then we store the display in
a Mutex. Finally, we unmask the <code>TIMER1</code> interrupt.</p>
<h2 id="display-api"><a class="header" href="#display-api">Display API</a></h2>
<p>We then define a couple of convenience functions which allow us to easily set (or unset) the image
to be displayed (<code>src/display/show.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::DISPLAY;

use cortex_m::interrupt::free as interrupt_free;

use tiny_led_matrix::Render;

/// Display an image.
pub fn display_image(image: &amp;impl Render) {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.show(image);
        }
    })
}

/// Clear the display (turn off all LEDs).
pub fn clear_display() {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.clear();
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_image</code> takes an image and tells the display to show it. Like the <code>Display::show</code> method
that it calls, this function takes a struct that implements the <code>tiny_led_matrix::Render</code>
trait. That trait ensures that the struct contains the data and methods necessary for the <code>Display</code>
to render it on the LED matrix. The two implementations of <code>Render</code> provided by the
<code>microbit::display::nonblocking</code> module are <code>BitImage</code> and <code>GreyscaleImage</code>. In a <code>BitImage</code>, each
&quot;pixel&quot; (or LED) is either illuminated or not (like when we used the blocking interface), whereas in
a <code>GreyscaleImage</code> each &quot;pixel&quot; can have a different brightness.</p>
<p><code>clear_display</code> does exactly as the name suggests.</p>
<h2 id="display-interrupt-handling"><a class="header" href="#display-interrupt-handling">Display interrupt handling</a></h2>
<p>Finally, we use the <code>interrupt</code> macro to define a handler for the <code>TIMER1</code> interrupt. This interrupt
fires many times a second, and this is what allows the <code>Display</code> to rapidly cycle the different LEDs
on and off to give the illusion of varying brightness levels. All our handler code does is call the
<code>Display::handle_display_event</code> method, which handles this (<code>src/display/interrupt.rs</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::DISPLAY;

use cortex_m::interrupt::free as interrupt_free;
use microbit::pac::{self, interrupt};

#[pac::interrupt]
fn TIMER1() {
    interrupt_free(|cs| {
        if let Some(display) = DISPLAY.borrow(cs).borrow_mut().as_mut() {
            display.handle_display_event();
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>Now we can understand how our <code>main</code> function will do display: we will call <code>init_display</code> and use
the new functions we have defined to interact with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snake-game-final-assembly"><a class="header" href="#snake-game-final-assembly">Snake game: final assembly</a></h1>
<p>The code in our <code>src/main.rs</code> file brings all the previously-discussed machinery together to make
our final game.</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

mod controls;
mod display;
pub mod game;

use controls::{get_turn, init_buttons};
use display::{clear_display, display_image, init_display};
use game::{Game, GameStatus};

use cortex_m_rt::entry;
use embedded_hal::delay::DelayNs;
use microbit::{
    display::nonblocking::{BitImage, GreyscaleImage},
    hal::{Rng, Timer},
    Board,
};
use panic_rtt_target as _;
use rtt_target::rtt_init_print;

#[entry]
fn main() -&gt; ! {
    rtt_init_print!();
    let board = Board::take().unwrap();
    let mut timer = Timer::new(board.TIMER0).into_periodic();
    let mut rng = Rng::new(board.RNG);
    let mut game = Game::new(&amp;mut rng);

    init_buttons(board.GPIOTE, board.buttons);
    init_display(board.TIMER1, board.display_pins);

    loop {
        loop {
            // Game loop
            let image = GreyscaleImage::new(&amp;game.game_matrix(6, 3, 9));
            display_image(&amp;image);
            timer.delay_ms(game.step_len_ms());
            match game.status {
                GameStatus::Ongoing =&gt; game.step(get_turn(true)),
                _ =&gt; {
                    for _ in 0..3 {
                        clear_display();
                        timer.delay_ms(200u32);
                        display_image(&amp;image);
                        timer.delay_ms(200u32);
                    }
                    clear_display();
                    display_image(&amp;BitImage::new(&amp;game.score_matrix()));
                    timer.delay_ms(2000u32);
                    break;
                }
            }
        }
        game.reset();
    }
}</code></pre></pre>
<p>After initialising the board and its timer and RNG peripherals, we initialise a <code>Game</code> struct and a
<code>Display</code> from the <code>microbit::display::blocking</code> module.</p>
<p>In our &quot;game loop&quot; (which runs inside of the &quot;main loop&quot; we place in our <code>main</code> function), we
repeatedly perform the following steps:</p>
<ol>
<li>
<p>Get a 5×5 array of bytes representing the grid. The <code>Game::get_matrix</code> method takes three integer
arguments (which should be between 0 and 9, inclusive) which will, eventually, represent how
brightly the head, tail and food should be displayed.</p>
</li>
<li>
<p>Display the matrix, for an amount of time determined by the <code>Game::step_len_ms</code> method. As
currently implemented, this method basically provides for 1 second between steps, reducing by
200ms every time the player scores 5 points (eating 1 piece of food = 1 point), subject to a
floor of 200ms.</p>
</li>
<li>
<p>Check the game status. If it is <code>Ongoing</code> (which is its initial value), run a step of the game
and update the game state (including its <code>status</code> property). Otherwise, the game is over, so
flash the current image three times, then show the player's score (represented as a number of
illuminated LEDs corresponding to the score), and exit the game loop.</p>
</li>
</ol>
<p>Our main loop just runs the game loop repeatedly, resetting the game's state after each iteration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-left-for-you-to-explore"><a class="header" href="#whats-left-for-you-to-explore">What's left for you to explore</a></h1>
<p>We have barely scratched the surface! There's lots of stuff left for you to
explore.</p>
<blockquote>
<p><strong>NOTE:</strong> If you're reading this, and you'd like to help add examples or
exercises to the Discovery book for any of the items below, or any other
relevant embedded topics, we'd love to have your help!</p>
<p>Please <a href="https://github.com/rust-embedded/discovery-mb2/issues/new">open an issue</a> if you would like to help, but need assistance or
mentoring for how to contribute this to the book, or open a Pull Request
adding the information!</p>
</blockquote>
<h2 id="topics-about-embedded-software"><a class="header" href="#topics-about-embedded-software">Topics about embedded software</a></h2>
<p>These topics discuss strategies for writing embedded software. Although many
problems can be solved in different ways, these sections talk about some
strategies, and when they make sense (or don't make sense) to use.</p>
<h3 id="multitasking"><a class="header" href="#multitasking">Multitasking</a></h3>
<p>Most of our programs executed a single task. How could we achieve multitasking in a system with no
OS, and thus no threads? There are two main approaches to multitasking: preemptive multitasking and
cooperative multitasking.</p>
<p>In preemptive multitasking a task that's currently being executed can, at any point in time, be
<em>preempted</em> (interrupted) by another task. On preemption, the first task will be suspended and the
processor will instead execute the second task. At some point the first task will be resumed.
Microcontrollers provide hardware support for preemption in the form of <em>interrupts</em>. We were
introduced to interrupts when we built our snake game in chapter 11.</p>
<p>In cooperative multitasking a task that's being executed will run until it reaches a <em>suspension
point</em>. When the processor reaches that suspension point it will stop executing the current task and
instead go and execute a different task. At some point the first task will be resumed. The main
difference between these two approaches to multitasking is that in cooperative multitasking <em>yields</em>
execution control at <em>known</em> suspension points instead of being forcefully preempted at any point of
its execution.</p>
<h3 id="sleeping"><a class="header" href="#sleeping">Sleeping</a></h3>
<p>All our programs have been continuously polling peripherals to see if there's anything that needs to
be done. However, sometimes there's nothing to be done!  At those times, the microcontroller should
&quot;sleep&quot;.</p>
<p>When the processor sleeps, it stops executing instructions and this saves power.  It's almost always
a good idea to save power so your microcontroller should be sleeping as much as possible. But, how
does it know when it has to wake up to perform some action? Interrupts are one of the events that
wake up the microcontroller but there are others. The ARM machine instructions <code>wfi</code> and <code>wfe</code> are
the instructions that make the processor &quot;sleep&quot; waiting for an interrupt or event.</p>
<h2 id="topics-related-to-microcontroller-capabilities"><a class="header" href="#topics-related-to-microcontroller-capabilities">Topics related to microcontroller capabilities</a></h2>
<p>Microcontrollers (like our nRF52/nRF51) have many capabilities. However, many share similar
capabilities that can be used to solve all sorts of different problems.</p>
<p>These topics discuss some of those capabilities, and how they can be used effectively
in embedded development.</p>
<h3 id="direct-memory-access-dma"><a class="header" href="#direct-memory-access-dma">Direct Memory Access (DMA).</a></h3>
<p>Some peripherals have DMA, a kind of <em>asynchronous</em> <code>memcpy</code> that allows the peripheral to move data
into or out of memory without the CPU being involved.</p>
<p>If you are working with a micro:bit v2 you have actually already used DMA: the HAL does this for you
with the UARTE and TWIM peripherals. A DMA peripheral can be used to perform bulk transfers of data:
either from RAM to RAM, from a peripheral like a UARTE, to RAM, or from RAM to a peripheral. You can
schedule a DMA transfer — for example &quot;read 256 bytes from UARTE into this buffer&quot; — and leave it
running in the background. You can check some register later to see if the transfer has completed,
or you can ask to receive an interrupt when the transfer completes. Thus, you can schedule the DMA
transfer and do other work while the transfer is ongoing.</p>
<p>The details of low-level DMA can be a bit tricky. We hope to add a chapter covering this topic in
the near future.</p>
<h3 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h3>
<p>We saw button interrupts briefly in [chapter 11].</p>
<p><a href="14-snake-game/controls.html">chapter 11</a></p>
<p>This introduced the key idea: in order to interact with the real world, it is often necessary for
the microcontroller to respond <em>immediately</em> when some kind of event occurs.</p>
<p>Microcontrollers have the ability to be interrupted, meaning when a certain event
occurs, it will stop whatever it is doing at the moment, to instead respond to that
event. This can be very useful when we want to stop a motor when a button is pressed,
or measure a sensor when a timer finishes counting down.</p>
<p>Although these interrupts can be very useful, they can also be a bit difficult
to work with properly. We want to make sure that we respond to events quickly,
but also allow other work to continue as well.</p>
<p>In Rust, we model interrupts similar to the concept of threading on desktop Rust
programs. This means we also must think about the Rust concepts of <code>Send</code> and <code>Sync</code>
when sharing data between our main application, and code that executes as part of
handling an interrupt event.</p>
<h3 id="pulse-width-modulation-pwm"><a class="header" href="#pulse-width-modulation-pwm">Pulse Width Modulation (PWM)</a></h3>
<p>In a nutshell, PWM is turning on something and then turning it off periodically
while keeping some proportion (&quot;duty cycle&quot;) between the &quot;on time&quot; and the &quot;off
time&quot;. When used on a LED with a sufficiently high frequency, this can be used
to dim the LED. A low duty cycle, say 10% on time and 90% off time, will make
the LED very dim wheres a high duty cycle, say 90% on time and 10% off time,
will make the LED much brighter (almost as if it were fully powered).</p>
<p>In general, PWM can be used to control how much <em>power</em> is given to some
electric device. With proper (power) electronics between a microcontroller and
an electrical motor, PWM can be used to control how much power is given to the
motor thus it can be used to control its torque and speed. Then you can add an
angular position sensor and you got yourself a closed loop controller that can
control the position of the motor at different loads.</p>
<p>There are some abstraction for working with PWM in the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/pwm/index.html"><code>pwm</code> module</a> and you will
find implementations of these traits in <code>nrf52833-hal</code>.</p>
<h3 id="digital-inputs-and-outputs"><a class="header" href="#digital-inputs-and-outputs">Digital inputs and outputs</a></h3>
<p>We have used the microcontroller pins as digital outputs, to drive LEDs. When building our snake
game, we also caught a glimpse of how these pins can be configured as digital inputs. As digital
inputs, these pins can read the binary state of switches (on/off) or buttons (pressed/not pressed).</p>
<p>Digital inputs and outputs are abstracted within the <code>embedded-hal</code> <a href="https://docs.rs/embedded-hal/latest/embedded_hal/digital/index.html"><code>digital</code> module</a> and
[<code>nrf52833-hal</code>] does have an implementation for them.</p>
<p>(<em>spoilers</em> reading the binary state of switches / buttons is not as straightforward as it sounds
;-) )</p>
<h3 id="analog-to-digital-converters-adc"><a class="header" href="#analog-to-digital-converters-adc">Analog-to-Digital Converters (ADC)</a></h3>
<p>There are a lot of digital sensors out there. You can use a protocol like I2C and SPI to read
them. But analog sensors also exist! These sensors just output a reading to the CPU of the voltage
they are sensing at an ADC input pin.</p>
<p>The ADC peripheral can thus be used to measure an &quot;analog&quot; voltage level — for example, <code>1.25</code> Volts
— as a &quot;digital&quot; number — for example, <code>24824</code> — that the processor can use in its calculations.</p>
<p>There were generic ADC traits in <code>embedded-hal</code>, but they were removed for <code>embedded-hal</code> 1.0: see
<a href="https://github.com/rust-embedded/embedded-hal/issues/377">issue #377</a>. The <code>nrf52833-hal</code> crate provides a nice interface to the specific ADC built into the
nRF52833.</p>
<h3 id="digital-to-analog-converters-dac"><a class="header" href="#digital-to-analog-converters-dac">Digital-to-Analog Converters (DAC)</a></h3>
<p>As you might expect a DAC is exactly the opposite of ADC. You can write some digital number into a
register to produce a specific voltage on some analog output pin. When this analog output pin is
connected to some appropriate electronics and the register is written to quickly with the right
values you can do things like produce sounds or music.</p>
<p>Neither the nRF52833 nor the MB2 board has a dedicated DAC. One typically gets a kind of DAC effect
by outputting PWM and using a bit of electronics on the output (RC filter) to &quot;smooth&quot; out the PWM
waveform.</p>
<h3 id="real-time-clock"><a class="header" href="#real-time-clock">Real Time Clock</a></h3>
<p>A Real-Time Clock peripheral keeps track of time under its own power, usually in &quot;human format&quot;:
seconds, minutes, hours, days, months and years.  Some Real-Time Clocks even handle leap years and
Daylight Saving Time automatically.</p>
<p>Neither the nRF52833 nor the MB2 board contains a Real-Time Clock. The nRF52833 does contain
&quot;Real-Time Counter&quot; (RTC), a low-frequency ticking clock that is supported by <code>nrf52833-hal</code>.  This
counter can be dedicated to serve as a synthesized real-time clock. The key requirement, of course,
is to keep the RTC peripheral powered even when the MB2 is not in use. While the MB2 does not have
an on-board battery, the RTC should be able to run for a long time (possibly years) with a battery
plugged into the battery port on the MB2 (for example, the battery pack provided with the micro::bit
Go kit).</p>
<h3 id="other-communication-protocols"><a class="header" href="#other-communication-protocols">Other communication protocols</a></h3>
<ul>
<li>I2C: discussed in earlier chapters of this book</li>
<li>SPI: abstracted within the <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/spi/index.html"><code>embedded-hal</code> <code>spi</code> module</a> and implemented by the [<code>nrf52-hal</code>]</li>
<li>I2S: currently not abstracted within the <code>embedded-hal</code> but implemented by the [<code>nrf52-hal</code>]</li>
<li>Ethernet: there does exist a small TCP/IP stack named <a href="https://github.com/smoltcp-rs/smoltcp"><code>smoltcp</code></a> which is implemented for some
chips. The MB2 does not have an Ethernet peripheral</li>
<li>USB: there is some experimental work on this, for example with the <a href="https://github.com/mvirkkunen/usb-device"><code>usb-device</code></a> crate</li>
<li>Bluetooth: the <code>nrf-softdevice</code> wrapper provided by the <code>Embassy</code> MB2 runtime is probably the
easiest entry into MB2 Bluetooth right now</li>
<li>CAN, SMBUS, IrDA, etc: All kinds of specialty interfaces exist in the world; Rust sometimes has
support for them. Please investigate the current situation for the interface you need</li>
</ul>
<p>Different applications use different communication protocols. User facing applications usually have
a USB connector because USB is a ubiquitous protocol in PCs and smartphones. Whereas inside cars
you'll find plenty of CAN buses. Some digital sensors use SPI, I2C or SMBUS.</p>
<p>If you happen to be interested in developing abstractions in the <code>embedded-hal</code> or implementations
of peripherals in general, don't be shy to open an issue in the HAL repositories. Alternatively you
could also join the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a> and get into contact with most of the people who
built the stuff from above.</p>
<h2 id="general-embedded-relevant-topics"><a class="header" href="#general-embedded-relevant-topics">General Embedded-Relevant Topics</a></h2>
<p>These topics cover items that are not specific to our device, or the hardware on it. Instead, they
discuss useful techniques that could be used on embedded systems. Most of what we will discuss here
is not available on the MB2 — but most of it could easily be added by connecting a cheap piece of
hardware to the MB2 edge-card connector, either driving it directly or using something like SPI or
I2C to control it.</p>
<h3 id="gyroscopes"><a class="header" href="#gyroscopes">Gyroscopes</a></h3>
<p>As part of our Punch-o-meter exercise, we used the Accelerometer to measure changes in acceleration
in three dimensions. But there are other motion sensors such as gyroscopes, which allows us to
measure changes in &quot;spin&quot; in three dimensions.</p>
<p>This can be very useful when trying to build certain systems, such as a robot that wants to avoid
tipping over. Additionally, the data from a sensor like a gyroscope can also be combined with data
from accelerometer using a technique called Sensor Fusion (see below for more information).</p>
<h3 id="servo-and-stepper-motors"><a class="header" href="#servo-and-stepper-motors">Servo and Stepper Motors</a></h3>
<p>While some motors are used primarily just to spin in one direction or the other, for example driving
a remote control car forwards or backwards, it is sometimes useful to measure more precisely how a
motor rotates.</p>
<p>A microcontroller can be used to drive Servo or Stepper motors, which allow for more precise control
of how many turns are being made by the motor, or can even position the motor in one specific place,
for example if we wanted to move the arms of a clock to a particular direction.</p>
<h3 id="sensor-fusion"><a class="header" href="#sensor-fusion">Sensor fusion</a></h3>
<p>The micro:bit contains two motion sensors: an accelerometer and a magnetometer.  On their own these
measure (proper) acceleration and (the Earth's) magnetic field.  But these magnitudes can be &quot;fused&quot;
into something more useful: a &quot;robust&quot; measurement of the orientation of the board, with less
measurement error than that of any single sensor.</p>
<p>This idea of deriving more reliable data from different sources is known as sensor fusion.</p>
<hr />
<p>So where to next? </p>
<p>First and foremost, join us on the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust Embedded matrix channel</a>. Lots of people who contribute or
work on embedded software hang out there, including, for example, the people who wrote the
<code>microbit</code> BSP, the <code>nrf52-hal</code> crate, the <code>embedded-hal</code> crates, etc. We are happy to help you get
started or move on with embedded programming in Rust!</p>
<p>There are many other options:</p>
<ul>
<li>You could check out the examples in the <a href="https://github.com/nrf-rs/microbit/"><code>microbit-v2</code></a> board support crate. All those examples
work for the micro:bit board you have.</li>
</ul>
<ul>
<li>If you are looking for a general overview of what is available in Rust Embedded right now check
out the <a href="https://github.com/rust-embedded/awesome-embedded-rust/">Awesome Rust Embedded</a> list.</li>
</ul>
<ul>
<li>You could check out <a href="https://embassy.dev">Embassy</a>. This is a modern efficient preemptive multitasking framework that
supports concurrent execution using Rust <code>async/await</code>.</li>
</ul>
<ul>
<li>You could check out Real-Time Interrupt-driven Concurrency <a href="https://rtic.rs">RTIC</a>. RTIC is a very efficient
preemptive multitasking framework that supports task prioritization and deadlock-free execution.</li>
</ul>
<ul>
<li>You could check out more abstractions of the <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> project and maybe even try and write
your own platform agnostic driver based on it.</li>
</ul>
<ul>
<li>You could try running Rust on a different development board. The easiest way to get started is to
use the <a href="https://docs.rs/cortex-m-quickstart/0.3.1/cortex_m_quickstart/"><code>cortex-m-quickstart</code></a> Cargo project template.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-troubleshooting"><a class="header" href="#general-troubleshooting">General troubleshooting</a></h1>
<h2 id="cargo-embed-problems"><a class="header" href="#cargo-embed-problems"><code>cargo-embed</code> problems</a></h2>
<p>Most <code>cargo-embed</code> problems are related to not having installed the <code>udev</code> rules properly on
Linux, so make sure you got that right.</p>
<p>If you are stuck, you can open an issue in the <a href="https://github.com/rust-embedded/discovery-mb2/issues"><code>discovery</code> issue tracker</a> or visit the <a href="https://matrix.to/#/#rust-embedded:matrix.org">Rust
Embedded matrix channel</a> or the <a href="https://matrix.to/#/#probe-rs:matrix.org">probe-rs matrix channel</a> and ask for help there.</p>
<h2 id="cargo-problems"><a class="header" href="#cargo-problems">Cargo problems</a></h2>
<h3 id="cant-find-crate-for-core"><a class="header" href="#cant-find-crate-for-core">&quot;can't find crate for <code>core</code>&quot;</a></h3>
<p><em>Symptoms:</em></p>
<pre><code>   Compiling volatile-register v0.1.2
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
Build failed, waiting for other jobs to finish...
error: Could not compile `r0`.

To learn more, run the command again with --verbose.
</code></pre>
<p><em>Cause:</em></p>
<p>You forgot to install the proper target for your microcontroller <code>thumbv7em-none-eabihf</code>.</p>
<p><em>Fix:</em></p>
<p>Install the proper target.</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-gdb"><a class="header" href="#how-to-use-gdb">How to use GDB</a></h1>
<p>Below are some useful GDB commands that can help us debug our programs. This assumes you have
<a href="appendix/2-how-to-use-gdb/../../05-meet-your-software/flash-it.html">flashed a program</a> onto your microcontroller and
attached GDB to a <code>cargo-embed</code> session.</p>
<h2 id="general-debugging"><a class="header" href="#general-debugging">General Debugging</a></h2>
<blockquote>
<p><strong>NOTE:</strong> Many of the commands you see below can be executed using a short form. For example,
<code>continue</code> can simply be used as <code>c</code>, or <code>break $location</code> can be used as <code>b $location</code>. Once you
have experience with the commands below, try to see how short you can get the commands to go
before GDB doesn't recognize them!</p>
</blockquote>
<h3 id="dealing-with-breakpoints"><a class="header" href="#dealing-with-breakpoints">Dealing with Breakpoints</a></h3>
<ul>
<li><code>break $location</code>: Set a breakpoint at a place in your code. The value of <code>$location</code> can include:
<ul>
<li><code>break *main</code> - Break on the exact address of the function <code>main</code></li>
<li><code>break *0x080012f2</code> - Break on the exact memory location <code>0x080012f2</code></li>
<li><code>break 123</code> - Break on line 123 of the currently displayed file</li>
<li><code>break main.rs:123</code> - Break on line 123 of the file <code>main.rs</code></li>
</ul>
</li>
<li><code>info break</code>: Display current breakpoints</li>
<li><code>delete</code>: Delete all breakpoints
<ul>
<li><code>delete $n</code>: Delete breakpoint <code>$n</code> (<code>n</code> being a number. For example: <code>delete $2</code>)</li>
</ul>
</li>
<li><code>clear</code>: Delete breakpoint at next instruction
<ul>
<li><code>clear main.rs:$function</code>: Delete breakpoint at entry of <code>$function</code> in <code>main.rs</code></li>
<li><code>clear main.rs:123</code>: Delete breakpoint on line 123 of <code>main.rs</code></li>
</ul>
</li>
<li><code>enable</code>: Enable all set breakpoints
<ul>
<li><code>enable $n</code>: Enable breakpoint <code>$n</code></li>
</ul>
</li>
<li><code>disable</code>: Disable all set breakpoints
<ul>
<li><code>disable $n</code>: Disable breakpoint <code>$n</code></li>
</ul>
</li>
</ul>
<h3 id="controlling-execution"><a class="header" href="#controlling-execution">Controlling Execution</a></h3>
<ul>
<li><code>continue</code>: Begin or continue execution of your program</li>
<li><code>next</code>: Execute the next line of your program
<ul>
<li><code>next $n</code>: Repeat <code>next</code> <code>$n</code> number times</li>
</ul>
</li>
<li><code>nexti</code>: Same as <code>next</code> but with machine instructions instead</li>
<li><code>step</code>: Execute the next line, if the next line includes a call to another function, step into that code
<ul>
<li><code>step $n</code>: Repeat <code>step</code> <code>$n</code> number times</li>
</ul>
</li>
<li><code>stepi</code>: Same as <code>step</code> but with machine instructions instead</li>
<li><code>jump $location</code>: Resume execution at specified location:
<ul>
<li><code>jump 123</code>: Resume execution at line 123</li>
<li><code>jump 0x080012f2</code>: Resume execution at address 0x080012f2</li>
</ul>
</li>
</ul>
<h3 id="printing-information"><a class="header" href="#printing-information">Printing Information</a></h3>
<ul>
<li>
<p><code>print /$f $data</code> - Print the value contained by the variable <code>$data</code>. Optionally format the
output with <code>$f</code>, which can include:</p>
<pre><code class="language-txt">x: hexadecimal
d: signed decimal
u: unsigned decimal
o: octal
t: binary
a: address
c: character
f: floating point
</code></pre>
<ul>
<li><code>print /t 0xA</code>: Prints the hexadecimal value <code>0xA</code> as binary (0b1010)</li>
</ul>
</li>
<li>
<p><code>x /$n$u$f $address</code>: Examine memory at <code>$address</code>. Optionally, <code>$n</code> define the number of units to
display, <code>$u</code> unit size (bytes, halfwords, words, etc.), <code>$f</code> any <code>print</code> format defined above</p>
<ul>
<li><code>x /5i 0x080012c4</code>: Print 5 machine instructions staring at address <code>0x080012c4</code></li>
<li><code>x/4xb $pc</code>: Print 4 bytes of memory starting where <code>$pc</code> currently is pointing</li>
</ul>
</li>
<li>
<p><code>disassemble $location</code></p>
<ul>
<li><code>disassemble /r main</code>: Disassemble the function <code>main</code>, using <code>/r</code> to show the bytes that make
up each instruction</li>
</ul>
</li>
</ul>
<h3 id="looking-at-the-symbol-table"><a class="header" href="#looking-at-the-symbol-table">Looking at the Symbol Table</a></h3>
<ul>
<li><code>info functions $regex</code>: Print the names and data types of functions matched by <code>$regex</code>, omit
<code>$regex</code> to print all functions
<ul>
<li><code>info functions main</code>: Print names and types of defined functions that contain the word <code>main</code></li>
</ul>
</li>
<li><code>info address $symbol</code>: Print where <code>$symbol</code> is stored in memory
<ul>
<li><code>info address GPIOC</code>: Print the memory address of the variable <code>GPIOC</code></li>
</ul>
</li>
<li><code>info variables $regex</code>: Print names and types of global variables matched by <code>$regex</code>, omit
<code>$regex</code> to print all global variables</li>
<li><code>ptype $data</code>: Print more detailed information about <code>$data</code>
<ul>
<li><code>ptype cp</code>: Print detailed type information about the variable <code>cp</code></li>
</ul>
</li>
</ul>
<h3 id="poking-around-the-program-stack"><a class="header" href="#poking-around-the-program-stack">Poking around the Program Stack</a></h3>
<ul>
<li><code>backtrace $n</code>: Print trace of <code>$n</code> frames, or omit <code>$n</code> to print all frames
<ul>
<li><code>backtrace 2</code>: Print trace of first 2 frames</li>
</ul>
</li>
<li><code>frame $n</code>: Select frame with number or address <code>$n</code>, omit <code>$n</code> to display current frame</li>
<li><code>up $n</code>: Select frame <code>$n</code> frames up</li>
<li><code>down $n</code>: Select frame <code>$n</code> frames down</li>
<li><code>info frame $address</code>: Describe frame at <code>$address</code>, omit <code>$address</code> for currently selected frame</li>
<li><code>info args</code>: Print arguments of selected frame</li>
<li><code>info registers $r</code>: Print the value of register <code>$r</code> in selected frame, omit <code>$r</code> for all
registers
<ul>
<li><code>info registers $sp</code>: Print the value of the stack pointer register <code>$sp</code> in the current frame</li>
</ul>
</li>
</ul>
<h3 id="controlling-cargo-embed-remotely"><a class="header" href="#controlling-cargo-embed-remotely">Controlling <code>cargo-embed</code> Remotely</a></h3>
<ul>
<li><code>monitor reset</code>: Reset the CPU, starting execution over again</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magnetometer-calibration"><a class="header" href="#magnetometer-calibration">Magnetometer Calibration</a></h1>
<p>One very important thing to do before using a sensor and trying to develop an application using it
is verifying that it's output is actually correct.  If this does not happen to be the case we need
to calibrate the sensor. Alternatively the sensor could be broken: health-checking sensors before
and during use is a really good idea when possible.</p>
<p>In my case, on two different MB2s the LSM303AGR's magnetometer without calibration is quite a bit
off.  (I also have one where the z-axis appears to be broken; the manufacturer has some extra
hardware and a process to help detect this, but we won't deal with that complexity here.)</p>
<p>There is a manufacturer-specified procedure for calibrating the magnetometer.  The calibration
involves quite a bit of math (matrices) so we won't cover it in detail here: this <a href="https://www.st.com/resource/en/design_tip/dt0103-compensating-for-magnetometer-installation-error-and-hardiron-effects-using-accelerometerassisted-2d-calibration-stmicroelectronics.pdf">Design Note</a>
describes the procedure if you are interested in the details.</p>
<p>Luckily for us, the CODAL group that built the original C++ software for the micro:bit already
implemented the manufacturer calibration mechanism (or something similar) in C++ over <a href="https://github.com/lancaster-university/codal-microbit-v2/blob/006abf5566774fbcf674c0c7df27e8a9d20013de/source/MicroBitCompassCalibrator.cpp">here</a>.</p>
<p>You can find a translation of this C++ calibration to Rust in <code>src/lib.rs</code>. Note that this is a
translation from Matlab to C++ to Rust, and that it makes some interesting choices.  In particular,
when reading calibrated values <em>the axes are flipped</em> so that viewed from the top with the USB
connector forward the X, Y and Z axes of the calibrated value are in &quot;standard&quot; (right, forward, up)
orientation.</p>
<p>The usage of this calibrator is demonstrated in <code>src/main.rs</code> here.</p>
<p>The way the user does the calibration is shown in this video from the C++ version. (Ignore the
initial printing — the calibration starts about halfway through.)</p>
<p align="center">
<video src="https://video.microbit.org/support/compass+calibration.mp4" loop autoplay>
</p>
<p>You have to tilt the micro:bit until all the LEDs on the LED matrix light up. The blinking cursor
shows the current target LED.</p>
<p>Note that the calibration matrix is printed by the demo program. This matrix can be hard-coded into
a program such as the <a href="appendix/3-mag-calibration/../../12-led-compass/index.html">chapter 9</a> compass program (or stored in flash somewhere somehow) to avoid
the need to recalibrate every time the user runs the program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
